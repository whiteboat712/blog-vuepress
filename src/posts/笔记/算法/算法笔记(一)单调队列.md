---
title: 算法笔记(一)单调队列
link: 算法笔记(一)单调队列
catalog: true

date: 2022-02-03 22:30:01 
subtitle: 单调队列笔记
tags:
- c++
- 算法
category:
- [笔记, 算法]
---

# 算法笔记：单调队列

这是第一次写算法笔记，可能自己的表达能力有限，所以标准就降低一些，只是留给以后的自己看。先前学习这个算法的时候一直搞不明白，去网上扒了很多篇文章去学，后来明白以后才发现这个算法也挺简单的。

## 单调队列

### 定义

单调队列顾名思义，就是构建一个队列，使这个队列**保持单调性**，定义很简单对吧？就是类似下面这样一个队列：

![img](https://pic2.zhimg.com/80/v2-b17c8fa093f26eb194e5fdf7c9c5d827_720w.jpg?source=d16d100b)

*用windows画图简单画的，很简陋不要吐槽。*

就像排队一样从高到低排，但是如果想要加入这个队列就只能从**队头**或者**队尾**进入，这是队列的特性。这里推荐一下我在别人博客见到的一句话，特别形象。

> **如果一个选手比你小还比你强，你就可以退役了。——单调队列**

好了，定义解释清楚了之后我们来看看这么个队列有个什么用。下面是一道标准的滑动窗口问题。

### 例题分析

题目来源 ：[acwing154.滑动窗口](https://www.acwing.com/problem/content/156/)

给定一个大小为 ![n≤10^6](https://www.zhihu.com/equation?tex=n%E2%89%A410%5E6)的数组。有一个大小为 ![k](https://www.zhihu.com/equation?tex=k) 的滑动窗口，它从数组的最左边移动到最右边。你只能在窗口中看到 ![k](https://www.zhihu.com/equation?tex=k)个数字。每次滑动窗口向右移动一个位置。

以下是一个例子：

该数组为 [1 3 -1 -3 5 3 6 7]， ![k](https://www.zhihu.com/equation?tex=k)为 ![3](https://www.zhihu.com/equation?tex=3) 。

|      窗口位置       | 最小值 | 最大值 |
| :-----------------: | :----: | :----: |
| [1 3 -1] -3 5 3 6 7 |   -1   |   3    |
| 1 [3 -1 -3] 5 3 6 7 |   -3   |   3    |
| 1 3 [-1 -3 5] 3 6 7 |   -3   |   5    |
| 1 3 -1 [-3 5 3] 6 7 |   -3   |   5    |
| 1 3 -1 -3 [5 3 6] 7 |   3    |   6    |
| 1 3 -1 -3 5 [3 6 7] |   3    |   7    |

你的任务是确定滑动窗口位于每个位置时，窗口中的**最大值**和**最小值**。

#### 输入格式

输入包含两行。

第一行包含两个整数 n 和k ，分别代表数组长度和滑动窗口的长度。第二行有 n 个整数，代表数组的具体数值。同行数据之间用空格隔开。

#### 输出格式

输出包含两个。

第一行输出，从左至右，每个位置滑动窗口中的最小值。

第二行输出，从左至右，每个位置滑动窗口中的最大值。

#### 输入样例：

```
8 3
1 3 -1 -3 5 3 6 7
```

#### 输出样例：

```
-1 -3 -3 -3 3 3
3 3 5 5 6 7
```

我们常人解决这个问题，很简单对吧，不过是看一眼找到方框里哪个最大哪个最小就行了，但是我们看一下数据范围， ![n\leq10^{6}](https://www.zhihu.com/equation?tex=n%5Cleq10%5E%7B6%7D),判题机的运行速度一般在每秒 ![10^{8}](https://www.zhihu.com/equation?tex=10%5E%7B8%7D) 次左右。假如我们采用最朴素的方式，每次方框向前移动一格，就扫描一遍方框，从中选出最小的和最大的值，这样的算法时间复杂度大概是 ![O(n \cdot k)](https://www.zhihu.com/equation?tex=O(n%20%5Ccdot%20k)) ,在这里也即 ![10^{6} \cdot 10^{6} = 10^{12}](https://www.zhihu.com/equation?tex=10%5E%7B6%7D%20%5Ccdot%2010%5E%7B6%7D%20%3D%2010%5E%7B12%7D)，那么在这里是必然会超时的。所以由此得知我们只能选用时间复杂度在 ![O(n \cdot log(n))](https://www.zhihu.com/equation?tex=O(n%20%5Ccdot%20log(n)))一下的算法。

当然如果你是大佬，使用线段树、ST表算法（时间复杂度 ![O(n \cdot log(n))](https://www.zhihu.com/equation?tex=O(n%20%5Ccdot%20log(n)))过也是可以的，不过在这里有点大材小用了。

**因为我们使用单调队列算法的时间复杂度只有 ![O(n)](https://www.zhihu.com/equation?tex=O(n))！**

代码层面也相对于那些算法更好写。下面我们来讲具体怎么使用单调队列。

### 具体实现

1. 首先我们使用一个数组来模拟一个双向队列：

```cpp
int head, tail, q[1000001];//q是队列
void maxn()
{
    head=1;tail=0;//记录队头和队尾
    for(int i=1;i<=n;i++)//对数组中每个元素进行处理
    {
        //code
    }
}
```

2. 我们发现一个性质：**如果队列中存在两个元素，满足 a[i]** ![\leq](https://www.zhihu.com/equation?tex=%5Cleq) **a[j] 且 i < j，那么无论在什么时候我们都不会取 a[i] 作为最大值了，所以可以直接将 a[i] 删掉**（也就是上面我推荐那一句名言)。此时队列中剩下的元素**严格单调递增**，队头就是其中的最大值，立刻就能找到。

先把找最大值的代码放出来，下面对样例进行详细分析

```cpp
int head,tail,q[1000001];
int p[1000001],k,n,a[1000001];
/*
1.p用来存储队列中元素在原数组中的序号
2.a是原数组
*/
void maxn()
{
    head=1;tail=0;//记录队头和队尾
    for(int i=1;i<=n;i++)
    {
        //假如队列还未清空并且新的所要被处理的元素比队尾的元素大
        //则队尾元素无可能是最大值，弹出队尾，一直循环
        while(head<=tail&&q[tail]<=a[i])
            --tail;//从队尾出队；
        q[++tail]=a[i];//入队；
        p[tail]=i;//记录在原序列位置
        while(p[head]<=i-k)//长度不超过k；
            head++;
        //输出队头元素，即为最大值。
        if(i>=k) printf("%d ",q[head]);
    }
    putchar('\n');
}
```

一开始队中没有一个元素，我们让1入队，此时，**q={1},p={1}。**

然后轮到3，我们需要思考：如果把3放进去，3有没有可能成为队列中最大的元素，显然现在队列中只有1,3比1大，3只要进去就是最大值，所以把1弹出3入队，此时，**q={3},p={2}**。

接下来是-1，显然它比队列中所有元素（也就是3）要小，但是也不能排除以后的元素都比它还要小，等到3出队后它成为最大值的可能，所以这次不弹出元素，-1入队，此时，**q={3,-1},p={2,3}**。

接下来是-3，和-1同理，比队列中所有元素（也就是3和-1）要小，但是它很靠前，所以入队，此时，**q={3,-1,-3},q={2,3,4}**。

接下来是5，这就**不一样了**，假如要让5入队，那队列就会变成**{3,-1,-3,5}，此时我们发现，3已经不是最大值了，并且中间的-1和-3也不可能成为最大值了，**因此为了保持队列的单调性，我们要将队列中的元素从队尾挨个和5比较，如果比5小就弹出，所以处理后3,-1,-3被弹出，此时只剩下了5，**q={5},p={5}**。

以此类推。。。。。

另外，我们还要关注一下序列长度的问题，假如队列的元素达到k，队头元素也就是最大的元素会弹出队列中第二大的元素会成为新的队头。

上述是求最大值大代码，求最小值的代码同理。

下面是完整代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int head,tail,q[1000001];
int p[1000001],k,n,a[1000001];
inline void maxn()
{
    head=1;tail=0;
    for(int i=1;i<=n;i++)
    {
        while(head<=tail&&q[tail]<=a[i])
            --tail;
        q[++tail]=a[i];
        p[tail]=i;
        while(p[head]<=i-k)
            head++;
        if(i>=k) cout << q[head] << " ";
    }
    cout << endl;
}
inline void minn()
{
    head=1;tail=0;
    for(int i=1;i<=n;i++)
    {
        while(head<=tail&&q[tail]>=a[i])
            --tail;
        q[++tail]=a[i];
        p[tail]=i;
        while(p[head]<=i-k)
            head++;
        if(i>=k) cout << q[head] << " ";
    } 
    cout << endl;
}
int main()
{
    cin >> n >> k;
    for(int i=1;i<=n;i++)
        cin >> a[i];
    minn();
    maxn();
    return 0;
}
```

**参考文章：**

https://zhuanlan.zhihu.com/p/346354943