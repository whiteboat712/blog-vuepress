---
title: 算法笔记(二)排序算法
link: 算法笔记(二)排序算法
catalog: true

date: 2022-02-04 22:30:01 
subtitle: 排序算法详解
tags:
- c++
- 算法
category:
- [笔记, 算法]
---

# 算法笔记：排序算法

## 说在前面的话

在网上经常见到一句程序员对新入行的新人说的话：

> 不要重复造轮子（Stop Trying to Reinvent the Wheel）

造轮子的意思就是重新编写别人实现过的代码，一般来说这样会效率低下，耗时耗力写出来的程序还不一定比别人的好。我每次看到这句话总会被莫名戳中笑点，也不知道笑点到底在哪个地方。

不过总的来说这句话对于大部分程序员是对的，毕竟对于现在那些大型软件，不可能要求一个程序员就把它完整的编写出来，对程序进行封装和打包，进行模块化编程才是王道。这样没人负责一个模块，不仅效率高，bug也好找。但是我觉得对于新入行的程序员，自己学习造一些轮子还是有很多帮助的，去了解那些程序底层的实现原理有助于开拓自己的思维。

## 排序算法分类

排序算法（Sorting algorithm）大概分为三类：

1. 简单排序算法：插入排序、冒泡排序、选择排序
2. 复杂排序算法：快速排序(yyds)、归并排序
3. 特殊排序算法：基数排序(简称：~~鸡排~~基排)、堆排序、桶排序

## 算法性质

### 稳定性

稳定性是指相等的元素经过排序之后相对顺序是否发生了改变。

拥有稳定性这一特性的算法会让原本有相等键值的纪录维持相对次序，即如果一个排序算法是稳定的，当有两个相等键值的纪录R和S，且在原本的列表中R出现在S之前，在排序过的列表中R也将会是在S之前。[摘自OI Wiki](https://oi-wiki.org/basic/sort-intro/)

### 时间复杂度

时间复杂度是定性描述算法的运行时间，不包括这个函数的低阶项和首项系数。

## 排序算法分析

### 简单排序算法

#### 选择排序

选择排序（Selection sort）是一种简单直观的排序算法。

**原理：**每次遍历数组找出第i小的数然后与第i位交换位置。

**性质**

- 稳定性：由于swap函数的存在，选择排序是一种不稳定的算法。
- 时间复杂度：稳定时间复杂度$O(n^2)$

**代码**

```cpp
// C++ version
void selection_sort(int* a, int n) {
  for (int i = 1; i < n; i++) {
    int min_num = i;
    for (int j = i + 1; j <= n; j++) {
      if (a[j] < a[min_num]) {
        min_num = j;
      }
    }
    std::swap(a[i], a[min_num]);
  }
}
```

#### 冒泡排序

冒泡排序（Bubble sort）是一种简单直观的排序算法，执行过程中仿佛气泡一样，逐渐小的数飘到最前面，大的数冒到最后面。

**原理：**每次检查相邻两个元素，如果逆序就交换这两个元素，直到数列有序。

**性质**

- 稳定性：冒泡排序很稳定。
- 时间复杂度：
  - 最好情况：数列有序，只需检查一遍数组，时间复杂度$O(n)$
  - 最坏情况：时间复杂度为$O(n^2)$
  - 平均情况：时间复杂度为$O(n^2)$

**代码**

```cpp
// C++ version
void bubble_sort(int* a, int n) {
  bool flag = true;
  while (flag) {
    flag = false;
    for (int i = 1; i < n; i++) {
      if (a[i] > a[i + 1]) {
        flag = true;
        std::swap(a[i], a[i + 1]);
      }
    }
  }
}
```

#### 插入排序

插入排序（Insertion sort）是一种简单直观的排序算法，就像打poker整理手牌一样。

**原理：**将数组中的元素分为*已排序*和*未排序*两部分，每次将未排序中的一个元素插入到已排序的元素中正确的位置。

**性质**

- 稳定性：插入排序很稳定。
- 时间复杂度：
  - 最好情况：数列有序，只需检查一遍数组，时间复杂度$O(n)$
  - 最坏情况：时间复杂度为$O(n^2)$
  - 平均情况：时间复杂度为$O(n^2)$

**代码**

```cpp
// C++ Version
void insertion_sort(int* a, int n) {
  // 对 a[1],a[2],...,a[n] 进行插入排序
  for (int i = 2; i <= n; ++i) {
    int key = a[i];
    int j = i - 1;
    while (j > 0 && a[j] > key) {
      a[j + 1] = a[j];
      j--;
    }
    a[j + 1] = key;
  }
}
```

### 复杂排序算法

#### 快速排序

快速排序（Quicksort），又称分区交换排序（partition-exchange sort），简称*快排*，是一种被广泛运用的排序算法。

**原理：**

快速排序分为三个过程：

1. 将数列划分为两部分（要求保证相对大小关系）；
2. 递归到两个子序列中分别进行快速排序；
3. 不用合并，因为此时数列已经完全有序。

和归并排序不同，第一步并不是直接分成前后两个序列，而是在分的过程中要保证相对大小关系。具体来说，第一步要是要把数列分成两个部分，然后保证前一个子数列中的数都小于后一个子数列中的数。为了保证平均时间复杂度，一般是随机选择一个数  来当做两个子数列的分界。

之后，维护一前一后两个指针  和 ，依次考虑当前的数是否放在了应该放的位置（前还是后）。如果当前的数没放对，比如说如果后面的指针  遇到了一个比  小的数，那么可以交换  和  位置上的数，再把  向后移一位。当前的数的位置全放对后，再移动指针继续处理，直到两个指针相遇。

其实，快速排序没有指定应如何具体实现第一步，不论是选择  的过程还是划分的过程，都有不止一种实现方法。

第三步中的序列已经分别有序且第一个序列中的数都小于第二个数，所以直接拼接起来就好了。

#### 归并排序

### 特殊排序算法

#### 基数排序

#### 堆排序

#### 桶排序



