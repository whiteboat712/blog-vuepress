const{entries:V}=Object,{fromEntries:et}=Object,st="ENTRIES",L="KEYS",T="VALUES",_="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===_)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==_).join("")}value(){return E(this._path).node.get(_)}result(){switch(this._type){case T:return this.value();case L:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],nt=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return R(e,t,s,n,i,1,o,""),n},R=(e,t,s,n,o,u,i,r)=>{const d=u*i;t:for(const c of e.keys())if(c===_){const a=o[d-1];a<=s&&n.set(r,[e.get(c),a])}else{let a=u;for(let h=0;h<c.length;++h,++a){const g=c[h],m=i*a,p=m-i;let l=o[m];const f=Math.max(0,a-s-1),y=Math.min(i-1,a+s);for(let F=f;F<y;++F){const v=g!==t[F],z=o[p+F]+ +v,A=o[p+F+1]+1,w=o[m+F]+1,j=o[m+F+1]=Math.min(z,A,w);j<l&&(l=j)}if(l>s)continue t}R(e.get(c),t,s,n,o,a,i,r+c)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==_&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ot(this._tree,t)}entries(){return new D(this,st)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return nt(this._tree,t,s)}get(t){const s=k(this._tree,t);return s!==void 0?s.get(_):void 0}has(t){const s=k(this._tree,t);return s!==void 0&&s.has(_)}keys(){return new D(this,L)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,I(this._tree,t).set(_,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);return n.set(_,s(n.get(_))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);let o=n.get(_);return o===void 0&&n.set(_,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==_&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},k=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==_&&t.startsWith(s))return k(e.get(s),t.slice(s.length))},I=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==_&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const d=e.get(u);if(r===u.length)e=d;else{const c=new Map;c.set(u.slice(r),d),e.set(t.slice(n,n+r),c),e.delete(u),e=c}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ot=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(_),s.size===0)W(n);else if(s.size===1){const[o,u]=s.entries().next().value;q(n,o,u)}}},W=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)W(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==_&&q(e.slice(0,-1),n,o)}},q=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],ut=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},it=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,M="or",$="and",rt="and_not",ct=(e,t)=>{e.includes(t)||e.push(t)},N=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},P=({score:e},{score:t})=>t-e,lt=()=>new Map,b=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},G=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,ht={[M]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),N(n.terms,u)}}return e},[$]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);N(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[rt]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},dt=(e,t,s,n,o,u)=>{const{k:i,b:r,d}=u;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/o)))},at=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},ft=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,lt),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},gt={k:1.2,b:.7,d:.5},mt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(it),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:M,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:gt},pt={combineWith:$,prefix:(e,t,s)=>t===s.length-1},Ft={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},_t={...Ft,...U},K=Symbol("*"),yt=(e,t)=>{const s=new Map,n={...e._options.searchOptions,...t};for(const[o,u]of e._documentIds){const i=n.boostDocument?n.boostDocument(u,"",e._storedFields.get(o)):1;s.set(o,{score:i,terms:[],match:{}})}return s},X=(e,t=M)=>{if(e.length===0)return new Map;const s=t.toLowerCase(),n=ht[s];if(!n)throw new Error(`Invalid combination operator: ${t}`);return e.reduce(n)||new Map},S=(e,t,s,n,o,u,i,r,d=new Map)=>{if(o==null)return d;for(const c of Object.keys(u)){const a=u[c],h=e._fieldIds[c],g=o.get(h);if(g==null)continue;let m=g.size;const p=e._avgFieldLength[h];for(const l of g.keys()){if(!e._documentIds.has(l)){ft(e,h,l,s),m-=1;continue}const f=i?i(e._documentIds.get(l),s,e._storedFields.get(l)):1;if(!f)continue;const y=g.get(l),F=e._fieldLength.get(l)[h],v=dt(y,m,e._documentCount,F,p,r),z=n*a*f*v,A=d.get(l);if(A){A.score+=z,ct(A.terms,t);const w=G(A.match,s);w?w.push(c):A.match[s]=[c]}else d.set(l,{score:z,terms:[t],match:{[s]:[c]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((l,f)=>({...l,[f]:G(n.boost,f)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:c,prefix:a}={...J.weights,...i},h=e._index.get(t.term),g=S(e,t.term,t.term,1,h,o,u,d);let m,p;if(t.prefix&&(m=e._index.atPrefix(t.term)),t.fuzzy){const l=t.fuzzy===!0?.2:t.fuzzy,f=l<1?Math.min(r,Math.round(t.term.length*l)):l;f&&(p=e._index.fuzzyGet(t.term,f))}if(m)for(const[l,f]of m){const y=l.length-t.term.length;if(!y)continue;p?.delete(l);const F=a*l.length/(l.length+.3*y);S(e,t.term,l,F,f,o,u,d,g)}if(p)for(const l of p.keys()){const[f,y]=p.get(l);if(!y)continue;const F=c*l.length/(l.length+y);S(e,t.term,l,F,f,o,u,d,g)}return g},Y=(e,t,s={})=>{if(t===K)return yt(e,s);if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(g=>Y(e,g,a));return X(h,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:d}=i,c=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(at(i)).map(a=>At(e,a,i));return X(c,i.combineWith)},Q=(e,t,s={})=>{const n=Y(e,t,s),o=[];for(const[u,{score:i,terms:r,match:d}]of n){const c=r.length||1,a={id:e._documentIds.get(u),score:i*c,terms:Object.keys(d),queryTerms:r,match:d};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return t===K&&s.boostDocument==null&&e._options.searchOptions.boostDocument==null||o.sort(P),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of Q(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=u,d.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:d}]of n)o.push({suggestion:u,terms:r,score:i/d});return o.sort(P),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?_t:t.autoVacuum;this._options={...mt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...pt,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:c},a)=>{if(c!==1&&c!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=b(n),h._idToShortId=new Map,h._fieldIds=o,h._fieldLength=b(u),h._avgFieldLength=i,h._storedFields=b(r),h._dirtCount=d||0,h._index=new C;for(const[g,m]of h._documentIds)h._idToShortId.set(m,g);for(const[g,m]of e){const p=new Map;for(const l of Object.keys(m)){let f=m[l];c===1&&(f=f.ds),p.set(parseInt(l,10),b(f))}h._index.set(g,p)}return h},B=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(c,a=!1)=>{let h="";i===0?h=c.length>20?`… ${c.slice(-20)}`:c:a?h=c.length+i>100?`${c.slice(0,100-i)}… `:c:h=c.length>20?`${c.slice(0,20)} … ${c.slice(-20)}`:c,h&&o.push(h),i+=h.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let d=s.indexOf(n,u);if(d===-1)return null;for(;d>=0;){const c=d+n.length;if(r(e.slice(u,d)),u=c,i>100)break;d=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},wt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),xt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),Z=(e,t,s={})=>{const n={};return Q(t,e,{boost:{h:2,t:1,c:4},prefix:!0,...s}).forEach(o=>{const{id:u,terms:i,score:r}=o,d=u.includes("@"),c=u.includes("#"),[a,h]=u.split(/[#@]/),g=Number(a),m=i.sort((l,f)=>l.length-f.length).filter((l,f)=>i.slice(f+1).every(y=>!y.includes(l))),{contents:p}=n[g]??={title:"",contents:[]};if(d)p.push([{type:"customField",id:g,index:h,display:m.map(l=>o.c.map(f=>B(f,l))).flat().filter(l=>l!==null)},r]);else{const l=m.map(f=>B(o.h,f)).filter(f=>f!==null);if(l.length&&p.push([{type:c?"heading":"title",id:g,...c&&{anchor:h},display:l},r]),"t"in o)for(const f of o.t){const y=m.map(F=>B(f,F)).filter(F=>F!==null);y.length&&p.push([{type:"text",id:g,...c&&{anchor:h},display:y},r])}}}),V(n).sort(([,o],[,u])=>"max"==="total"?wt(o,u):xt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=ut(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},tt=(e,t,s={})=>{const n=Ct(t,e,{fuzzy:.2,maxFuzzy:3,...s}).map(({suggestion:o})=>o);return e.includes(" ")?n:n.filter(o=>!o.includes(" "))},bt=et(V(JSON.parse("{\"/en/\":{\"documentCount\":2,\"nextId\":2,\"documentIds\":{\"0\":\"2\",\"1\":\"3\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[2,30],\"1\":[2,7]},\"averageFieldLength\":[2,18.5],\"storedFields\":{\"0\":{\"h\":\"Blog Home\",\"t\":[\"This is a blog home page demo.\",\"To use this layout, you should set both layout: BlogHome and home: true in the page front matter.\",\"For related configuration docs, please see blog homepage.\"]},\"1\":{\"h\":\"Intro Page\",\"t\":[\"Place your introduction and profile here.\"]}},\"dirtCount\":0,\"index\":[[\"here\",{\"1\":{\"1\":1}}],[\"homepage\",{\"1\":{\"0\":1}}],[\"home\",{\"0\":{\"0\":1},\"1\":{\"0\":2}}],[\"profile\",{\"1\":{\"1\":1}}],[\"place\",{\"1\":{\"1\":1}}],[\"please\",{\"1\":{\"0\":1}}],[\"page\",{\"0\":{\"1\":1},\"1\":{\"0\":2}}],[\"docs\",{\"1\":{\"0\":1}}],[\"demo\",{\"1\":{\"0\":1}}],[\"configuration\",{\"1\":{\"0\":1}}],[\"related\",{\"1\":{\"0\":1}}],[\"for\",{\"1\":{\"0\":1}}],[\"front\",{\"1\":{\"0\":1}}],[\"matter\",{\"1\":{\"0\":1}}],[\"introduction\",{\"1\":{\"1\":1}}],[\"intro\",{\"0\":{\"1\":1}}],[\"in\",{\"1\":{\"0\":1}}],[\"is\",{\"1\":{\"0\":1}}],[\"both\",{\"1\":{\"0\":1}}],[\"bloghome\",{\"1\":{\"0\":1}}],[\"blog\",{\"0\":{\"0\":1},\"1\":{\"0\":2}}],[\"see\",{\"1\":{\"0\":1}}],[\"set\",{\"1\":{\"0\":1}}],[\"should\",{\"1\":{\"0\":1}}],[\"your\",{\"1\":{\"1\":1}}],[\"you\",{\"1\":{\"0\":1}}],[\"layout\",{\"1\":{\"0\":2}}],[\"use\",{\"1\":{\"0\":1}}],[\"the\",{\"1\":{\"0\":1}}],[\"this\",{\"1\":{\"0\":2}}],[\"true\",{\"1\":{\"0\":1}}],[\"to\",{\"1\":{\"0\":1}}],[\"and\",{\"1\":{\"0\":1,\"1\":1}}],[\"a\",{\"1\":{\"0\":1}}]],\"version\":2},\"/\":{\"documentCount\":123,\"nextId\":123,\"documentIds\":{\"0\":\"1\",\"1\":\"5\",\"2\":\"6\",\"3\":\"7\",\"4\":\"7#技术栈\",\"5\":\"7#实现过程\",\"6\":\"7#主逻辑\",\"7\":\"7#用户行为\",\"8\":\"7#状态机\",\"9\":\"7#用户输入处理\",\"10\":\"7#创建棋盘\",\"11\":\"7#棋盘操作\",\"12\":\"7#随机生成一个-2-或者-4\",\"13\":\"7#重置棋盘\",\"14\":\"7#一行向左合并\",\"15\":\"7#矩阵转置与矩阵逆转\",\"16\":\"7#棋盘走一步\",\"17\":\"7#判断输赢\",\"18\":\"7#判断能否移动\",\"19\":\"7#绘制游戏界面\",\"20\":\"7#完成主逻辑\",\"21\":\"7#运行\",\"22\":\"7#面向对象重构\",\"23\":\"7#action类\",\"24\":\"7#grid类\",\"25\":\"7#reset\",\"26\":\"7#add-random-item\",\"27\":\"7#transpose\",\"28\":\"7#invert\",\"29\":\"7#move-row-left\",\"30\":\"7#tighten\",\"31\":\"7#merge\",\"32\":\"7#move-left\",\"33\":\"7#move-right\",\"34\":\"7#move-up\",\"35\":\"7#move-down\",\"36\":\"7#row-can-move-left\",\"37\":\"7#can-move-left\",\"38\":\"7#can-move-right\",\"39\":\"7#can-move-up\",\"40\":\"7#can-move-down\",\"41\":\"7#screen类\",\"42\":\"7#cast\",\"43\":\"7#draw-row\",\"44\":\"7#draw\",\"45\":\"7#gamemanager类\",\"46\":\"7#reset-1\",\"47\":\"7#screen\",\"48\":\"7#move\",\"49\":\"7#is-win\",\"50\":\"7#is-over\",\"51\":\"7#can-move\",\"52\":\"7#state-init\",\"53\":\"7#state-game\",\"54\":\"7#restart-or-exit\",\"55\":\"7#state-win\",\"56\":\"7#state-over\",\"57\":\"7#call\",\"58\":\"8\",\"59\":\"8#前言\",\"60\":\"8#反思\",\"61\":\"8@0\",\"62\":\"9\",\"63\":\"9@0\",\"64\":\"10\",\"65\":\"11\",\"66\":\"12\",\"67\":\"13\",\"68\":\"14\",\"69\":\"15\",\"70\":\"16\",\"71\":\"17\",\"72\":\"17@0\",\"73\":\"18\",\"74\":\"18@0\",\"75\":\"19\",\"76\":\"20\",\"77\":\"21\",\"78\":\"22\",\"79\":\"23\",\"80\":\"24\",\"81\":\"25\",\"82\":\"25#单调队列\",\"83\":\"25#定义\",\"84\":\"25#例题分析\",\"85\":\"25#输入格式\",\"86\":\"25#输出格式\",\"87\":\"25#输入样例\",\"88\":\"25#输出样例\",\"89\":\"25#具体实现\",\"90\":\"26\",\"91\":\"26#说在前面的话\",\"92\":\"26#排序算法分类\",\"93\":\"26#算法性质\",\"94\":\"26#稳定性\",\"95\":\"26#时间复杂度\",\"96\":\"26#排序算法分析\",\"97\":\"26#简单排序算法\",\"98\":\"26#选择排序\",\"99\":\"26#冒泡排序\",\"100\":\"26#插入排序\",\"101\":\"26#复杂排序算法\",\"102\":\"26#快速排序\",\"103\":\"26#归并排序\",\"104\":\"26#特殊排序算法\",\"105\":\"26#基数排序\",\"106\":\"26#堆排序\",\"107\":\"26#桶排序\",\"108\":\"27\",\"109\":\"27#栈\",\"110\":\"27#java实现\",\"111\":\"27#代码\",\"112\":\"28\",\"113\":\"29\",\"114\":\"30\",\"115\":\"31\",\"116\":\"32\",\"117\":\"33\",\"118\":\"34\",\"119\":\"35\",\"120\":\"36\",\"121\":\"37\",\"122\":\"38\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1,40],\"1\":[1],\"2\":[1,109],\"3\":[1,5],\"4\":[1,9],\"5\":[1,22],\"6\":[1],\"7\":[1,58],\"8\":[1,114],\"9\":[1,22],\"10\":[1,30],\"11\":[1],\"12\":[4,58],\"13\":[1,24],\"14\":[1,54],\"15\":[1,27],\"16\":[1,54],\"17\":[1,53],\"18\":[1,65],\"19\":[1,80],\"20\":[1,86],\"21\":[1,14],\"22\":[1],\"23\":[1,40],\"24\":[1,3],\"25\":[1,19],\"26\":[3,30],\"27\":[1,12],\"28\":[1,11],\"29\":[3,2],\"30\":[1,16],\"31\":[1,34],\"32\":[2,11],\"33\":[2,8],\"34\":[2,8],\"35\":[2,8],\"36\":[4,26],\"37\":[3,12],\"38\":[3,10],\"39\":[3,9],\"40\":[3,77],\"41\":[1,28],\"42\":[1,9],\"43\":[2,19],\"44\":[1,64],\"45\":[1,3],\"46\":[1,18],\"47\":[1,19],\"48\":[1,19],\"49\":[2,17],\"50\":[2,17],\"51\":[2,13],\"52\":[2,9],\"53\":[2,24],\"54\":[4,17],\"55\":[2,9],\"56\":[2,9],\"57\":[2,17],\"58\":[1],\"59\":[1,15],\"60\":[1,52],\"61\":[null,null,2],\"62\":[3,7],\"63\":[null,null,2],\"64\":[3,5],\"65\":[2,8],\"66\":[2,7],\"67\":[3,8],\"68\":[4,9],\"69\":[2,2],\"70\":[2,6],\"71\":[5,2],\"72\":[null,null,2],\"73\":[3,6],\"74\":[null,null,2],\"75\":[4,8],\"76\":[4,8],\"77\":[2,8],\"78\":[2,9],\"79\":[3,14],\"80\":[3,8],\"81\":[3,8],\"82\":[1],\"83\":[1,20],\"84\":[1,25],\"85\":[1,10],\"86\":[1,7],\"87\":[2,6],\"88\":[2,30],\"89\":[1,142],\"90\":[3],\"91\":[1,25],\"92\":[1,18],\"93\":[1],\"94\":[1,8],\"95\":[1,3],\"96\":[1],\"97\":[1],\"98\":[1,38],\"99\":[1,49],\"100\":[1,45],\"101\":[1],\"102\":[1,48],\"103\":[1],\"104\":[1],\"105\":[1],\"106\":[1],\"107\":[1],\"108\":[1,18],\"109\":[1,22],\"110\":[1,31],\"111\":[1,50],\"112\":[1,13],\"113\":[1,3],\"114\":[1],\"115\":[1],\"116\":[1],\"117\":[2],\"118\":[1],\"119\":[1],\"120\":[1],\"121\":[2],\"122\":[1]},\"averageFieldLength\":[1.614659857254486,26.055873201150792,0.11501104728236854],\"storedFields\":{\"0\":{\"h\":\"关于\",\"t\":[\"可能以前真的很羡慕那些有自己博客的人，为什么呢？拥有自己的小站并且可以在上面发布自己的文章，看起来也没什么了不起嘛，呵。但是可能自己真的有赛博仓鼠的囤积癖，有一个自己拥有绝对控制权的网站，在上面记录自己的点滴成长，想想也是一件很幸福的事情。\",\"2022/10/2 CCPC河南省赛结束，感觉队友们都很默契啊，整个学校打的也争气的，咱也拿了个第一个金牌。\",\"2022/9/25 ICPC网络赛Content2结束了,又进步了一点点吧，但是没有什么特别开心的，两场比赛依旧是一个名额都没抢到。\",\"2022/9/18 ICPC网络赛Content1结束了，相比上次真是飞跃的进步。\",\"2022/9/12 hexo博客终于弄好啦！🥳\",\"2022/9/11 ccpc网络赛结束，以后坚持每周模拟战吧。\",\"2022/8/12 基于wordpress的博客上线，但是都是php真的看不懂啊！呜呜呜~\",\"2022/5/22 既然选择在xcpc这条路上走，就该抛弃所有杂念。\"]},\"1\":{\"h\":\"Projects\"},\"2\":{\"h\":\"封寝十天小记\",\"t\":[\"3e0594757ea2535b5aeb9611fde91794c2cd3dd4ea4f3312d.png\",\"不知不觉在寝室已经封了十天了，所谓的新冠疫情已经耽误了太多太多的事情了，现在在寝室里面最大的事情也不过是早上吃什么、中午吃什么、晚上吃什么，学习相关的事情也是尽量跟上，毕竟大学上网课，能进脑子的知识估计能有十分之一都不错了。按照老师们说的，目前维持自己的精神状态正常才最重要hhh。这也是我这几天这几十天咕咕咕连个破文章都没更新的原因。\",\"走廊\",\"看着平常里熙熙攘攘的校园还有宿舍的走廊里变得如此宁静，在刚封寝的那几天我其实内心还是有点欣喜的（没有任何别的意思），因为我其实很喜欢安静的地方，而且有免费的饭菜，窝在寝室里默默的学习和努力还是挺好的，平时正常上课的时候我也认为去教室上课不如自学，可能是认为自己的学校的教育资源不如网上的吧（确实是一个错误的观点）。一开始定了一个目标，就是在保证正常学习的进度下再把java的springboot框架给学了，还可以偶尔看看书，写写文章。\",\"IMG-20221028-162248.jpg\",\"但是，封寝几天之后逐渐就开始崩坏了，每天固定的捅一次喉咙+捅两次鼻子，自己的计划几乎被打乱了，被封寝之后的物资短缺几乎让我退化到了只要keep live就好了，对学习根本打不起兴趣，虽然很喜欢扩展一些编程知识，但没什么斗志，碰到难以解决的问题就搁置了，对于算法的学习也搁置了，基本上只完成了老师布置的作业，还有给新生出的题现在还有几道没出，饭菜虽然免费，但其质量很堪忧，以至于是几乎不能吃的感觉，一盆菜里面面就几个肉丝，那个菜还十分难吃。\",\"IMG-20221106-181748.jpg\",\"这个图里能看到的肉几乎就是全部了，上面那个包菜还巨难吃，米还有点生。其实这些还不是最重要的，或者根本不值一提。\",\"疫情之前连着打了一个月的比赛，CCPC和ICPC的网络选拔赛，还有河南省赛，甚至封寝前几天还打了一场河北省赛。只能说是拼死拼活（虽然我们队伍不是最强的），打下来了几个名额，ICPC亚洲区域赛的名额真的是太宝贵了，7个名额，如果能参加，拿个铜牌也是足够拿到简历上加很多分的，这一来疫情耽误了，报名过的比赛被迫退赛，估计只能等到明年再打了，不过，训练了一年半了，只为了打明年的比赛，不论是时间成本还是精力，算起来都太亏了，而且如果明年拿不到奖牌，那这两年半的训练算是打水漂了，没有结果 ，大学四年浪费八分之五。\",\"确实是心里有点难受，越想越难受，所以在这里写出来发泄一下，没有什么条理，没有什么逻辑，就是很不爽。我也知道，写出来并不能改变什么，世界上总是有一些事与愿违的事情，没有那个运气和实力，选错了方向可能努力也没什么结果，现在或许我应该把重心放到更加稳妥的方向了吧，算法固然算是一个梦想，但是还是要脚踏实地学点什么养活自己再说。\",\"好想回到没有疫情的时候啊！！！！！！\",\"CR11u-20221023-101842854.jpg\",\"下面放一些比赛时的照骗：\",\"wx-camera-1664680508938.jpg\",\"河南省赛\",\"wx-camera-1663385267713.jpg\",\"应该是第一场ICPC网络预选赛\",\"wx-camera-1664527222954.jpg\",\"大概是第二场吧\",\"mmexport1665747871951.jpg\",\"目前拿过的最高荣誉！！！！！\"]},\"3\":{\"h\":\"Python实现2048\",\"t\":[\"看到某网站上有一门实战课，所以就跑过来跟着实现一下这个。\",\"应该不难吧，哈哈哈。\"]},\"4\":{\"h\":\"技术栈\",\"t\":[\"Python 基本知识\",\"curses 终端图形编程库\",\"random 随机数模块\",\"collections 容器数据类型库\",\"状态机的概念\"]},\"5\":{\"h\":\"实现过程\",\"t\":[\"在根目录下创建游戏文件 2048.py\",\"导入需要的包\",\"# curses 用来在终端上显示图形界面 import curses # random 模块用来生成随机数 from random import randrange, choice # collections 提供了一个字典的子类 defaultdict。可以指定 key 值不存在时，value 的默认值。 from collections import defaultdict\",\"PS：这个curses后面真的折磨了我好久\"]},\"6\":{\"h\":\"主逻辑\"},\"7\":{\"h\":\"用户行为\",\"t\":[\"所有的有效输入都可以转换为\\\"上，下，左，右，游戏重置，退出\\\"这六种行为，用 actions 表示\",\"actions = ['Up', 'Left', 'Down', 'Right', 'Restart', 'Exit']\",\"有效输入键是最常见的 W（上），A（左），S（下），D（右），R（重置），Q（退出），这里要考虑到大写键开启的情况，获得有效键值列表：\",\"# ord() 函数以一个字符作为参数，返回参数对应的 ASCII 数值，便于和后面捕捉的键位关联 letter_codes = [ord(ch) for ch in 'WASDRQwasdrq']\",\"将输入与行为进行关联：\",\"actions_dict = dict(zip(letter_codes, actions * 2))\",\"# actions_dict 的输出结果为 {87: 'Up', 65: 'Left', 83: 'Down', 68: 'Right', 82: 'Restart', 81: 'Exit', 119: 'Up', 97: 'Left', 115: 'Down', 100: 'Right', 114: 'Restart', 113: 'Exit'}\"]},\"8\":{\"h\":\"状态机\",\"t\":[\"处理游戏主逻辑的时候我们会用到一种十分常用的技术：状态机，或者更准确的说是有限状态机（FSM）\",\"你会发现 2048 游戏很容易就能分解成几种状态的转换。\",\"2.1-1\",\"state 存储当前状态， state_actions 这个词典变量作为状态转换的规则，它的 key 是状态，value 是返回下一个状态的函数：\",\"Init: init()\",\"Game\",\"Game: game()\",\"Game\",\"Win\",\"GameOver\",\"Exit\",\"Win: lambda: not_game('Win')\",\"Init\",\"Exit\",\"Gameover: lambda: not_game('Gameover')\",\"Init\",\"Exit\",\"Exit: 退出循环\",\"状态机会不断循环，直到达到 Exit 终结状态结束程序。\",\"下面我们来理清主逻辑的代码：\",\"init函数用来初始化我们的游戏棋盘，使游戏变成初始状态。\",\"初始化棋盘\",\"def init(): ''' 初始化游戏棋盘 ''' return 'Game'\",\"not_game函数表示的是游戏结束时的状态。游戏结束时，只有胜利和失败两种结果。在展示这两种结果的同时，我们还需要为玩家提供“Restart”和“Exit”功能。\",\"def not_game(state): '''展示游戏结束界面。 读取用户输入得到 action，判断是重启游戏还是结束游戏 ''' # defaultdict 参数是 callable 类型，所以需要传一个函数 responses = defaultdict(lambda: state) # 在字典中新建两个键值对 responses['Restart'], responses['Exit'] = 'Init', 'Exit' return responses[action]\",\"这里 defaultdict 作用是生成一个特殊的字典 responses。 在普通的字典里，我们都知道如果使用字典里不存在的 key 来取 value，程序就会报错。 但在 defaultdict 生成的特殊字典里，如果要取的 key 不存在，程序不仅不会报错，还能取到一个我们设定的默认 value 值。 也就是说，在 responses 这个特殊字典里，responses[action] 在 action 为 'Restart' 、'Exit' 这两种行为时分别对应 'Init' 和 'Exit' 状态。 在 keyaction 为 actions = ['Up', 'Left', 'Down', 'Right', 'Restart', 'Exit'] 中的其他行为时，对应的都是默认的 valuestate。\",\"这样一来，在游戏结束界面，玩家输入 r 和 q 以外的键位都不能对游戏界面造成影响。\",\"game函数表示的是游戏进行时的状态，在不重新开始或退出的情况下，只要游戏没有胜利或失败，就会一直处于游戏状态。\",\"游戏状态\",\"def game(): '''画出当前棋盘状态 读取用户输入得到 action ''' if action == 'Restart': return 'Init' if action == 'Exit': return 'Exit' # if 成功移动了一步: if 游戏胜利了: return 'Win' if 游戏失败了: return 'Gameover' return 'Game'\",\"这里同样会获取用户输入得到 action。 当 action 为 'Restart'、'Exit'时会执行“Restart”、“Exit”功能。 不同的是，当 action 为 'Up'、'Left'、'Down'、'Right' 行为时，棋盘会进行相应移动一次，然后判断游戏是否结束。如果结束就返回相应的结束状态，没有结束就返回状态 'Game'，表示还在游戏进行状态。\"]},\"9\":{\"h\":\"用户输入处理\",\"t\":[\"阻塞＋循环，直到获得用户有效输入才返回对应行为：\",\"def get_user_action(keyboard): char = \\\"N\\\" while char not in actions_dict: # 返回按下键位的 ASCII 码值 char = keyboard.getch() # 返回输入键位对应的行为 return actions_dict[char]\"]},\"10\":{\"h\":\"创建棋盘\",\"t\":[\"初始化棋盘的参数，可以指定棋盘的高和宽以及游戏胜利条件，默认是最经典的 4x4 ～ 2048。\",\"class GameField(object): def __init__(self, height=4, width=4, win=2048): self.height = height # 高 self.width = width # 宽 self.win_value = 2048 # 过关分数 self.score = 0 # 当前分数 self.highscore = 0 # 最高分 self.reset() # 棋盘重置\"]},\"11\":{\"h\":\"棋盘操作\"},\"12\":{\"h\":\"随机生成一个 2 或者 4\",\"t\":[\"def spawn(self): # 从 100 中取一个随机数，如果这个随机数大于 89，new_element 等于 4，否则等于 2 new_element = 4 if randrange(100) > 89 else 2 # 得到一个随机空白位置的元组坐标 (i,j) = choice([(i,j) for i in range(self.width) for j in range(self.height) if self.field[i][j] == 0]) self.field[i][j] = new_element\",\"按照游戏规则，这里需要在棋盘中随机找到一个空白的位置，并在这个位置上随机生成一个 2 或 4。 于是，我们用到了 random 库的 randrange 和 choice 方法。randrange 用法参考上面代码块中的注释。 choice 方法会从一个非空的序列（list、str、tuple 等）中随机返回一个元素。可是我们需要知道象征着棋盘的这个二维数组的 i 和 j 才能确定棋盘上的位置。 因此，在上面的代码中，我们往 choice 方法中传入一个列表，并在列表生成式中将二维数组变成一个以 (i,j) 为元素的列表，同时排除掉非零的位置。\"]},\"13\":{\"h\":\"重置棋盘\",\"t\":[\"def reset(self): # 更新分数 if self.score > self.highscore: self.highscore = self.score self.score = 0 # 初始化游戏开始界面 self.field = [[0 for i in range(self.width)] for j in range(self.height)] self.spawn() self.spawn()\",\"reset 方法在棋盘初始化的时候被调用。它的主要作用是将棋盘所有位置元素复原为 0，然后再在随机位置生成游戏初始的数值。\"]},\"14\":{\"h\":\"一行向左合并\",\"t\":[\"(注：这一操作是在 move 内定义的，拆出来是为了方便阅读)\",\"def move_row_left(row): def tighten(row): '''把零散的非零单元挤到一块''' # 先将非零的元素全拿出来加入到新列表 new_row = [i for i in row if i != 0] # 按照原列表的大小，给新列表后面补零 new_row += [0 for i in range(len(row) - len(new_row))] return new_row def merge(row): '''对邻近元素进行合并''' pair = False new_row = [] for i in range(len(row)): if pair: # 合并后，加入乘 2 后的元素在 0 元素后面 new_row.append(2 * row[i]) # 更新分数 self.score += 2 * row[i] pair = False else: # 判断邻近元素能否合并 if i + 1 < len(row) and row[i] == row[i + 1]: pair = True # 可以合并时，新列表加入元素 0 new_row.append(0) else: # 不能合并，新列表中加入该元素 new_row.append(row[i]) # 断言合并后不会改变行列大小，否则报错 assert len(new_row) == len(row) return new_row # 先挤到一块再合并再挤到一块 return tighten(merge(tighten(row)))\"]},\"15\":{\"h\":\"矩阵转置与矩阵逆转\",\"t\":[\"加入这两个操作可以大大节省我们的代码量，减少重复劳动。\",\"矩阵转置：\",\"矩阵转置\",\"对于像我们棋盘一样，4 × 4 的二维矩阵，我们可以直接利用 Python 内置的 zip(*) 方法来进行矩阵转置。\",\"def transpose(field): return [list(row) for row in zip(*field)]\",\"矩阵逆转（不是逆矩阵）：\",\"这里只是将矩阵的每一行倒序，和逆矩阵的概念无关。\",\"def invert(field): return [row[::-1] for row in field]\"]},\"16\":{\"h\":\"棋盘走一步\",\"t\":[\"通过对矩阵进行转置与逆转，可以直接从左移得到其余三个方向的移动操作\",\"(注：这里省略 move 函数里的部分代码)\",\"def move(self, direction): # 创建 moves 字典，把不同的棋盘操作作为不同的 key，对应不同的方法函数 moves = {} moves['Left'] = lambda field: [move_row_left(row) for row in field] moves['Right'] = lambda field: invert(moves['Left'](invert(field))) moves['Up'] = lambda field: transpose(moves['Left'](transpose(field))) moves['Down'] = lambda field: transpose(moves['Right'](transpose(field))) # 判断棋盘操作是否存在且可行 if direction in moves: if self.move_is_possible(direction): self.field = moves[direction](self.field) self.spawn() return True else: return False\",\"在 moves 字典中有 Left、Right、Up、Down 四个 key 对应四种棋盘操作。 我们先判断传进来作为 key 的 direction 操作是否存在 move 字典中。如果存在的话，我们再用 move_is_possible 方法判断这个操作是否能在棋盘执行。 这两个判断都通过后，就会对棋盘进行相应移动操作。 这里的难点在于理解矩阵转置和逆转后和原矩阵的关系。如果想不明白，可以在纸上画出变化前后的矩阵对比。\"]},\"17\":{\"h\":\"判断输赢\",\"t\":[\"def is_win(self): # 任意一个位置的数大于设定的 win 值时，游戏胜利 return any(any(i >= self.win_value for i in row) for row in self.field) def is_gameover(self): # 无法移动和合并时，游戏失败 return not any(self.move_is_possible(move) for move in actions)\",\"在 is_win 函数方法中，我们使用了 Python 内置的 any 函数，any 接收一个可迭代对象作为参数(iterable),返回 bool 值。 这里的 any 里面嵌套了另一个 any，里层的 any 传入了每一行的元素并依次比较这一行的每个元素与 self.win_value 的大小，如果有任何一个元素大于 self.win_value，就返回 True,否则返回 False；外层的 any 传入的是矩阵每一行元素在内层 any 里处理后返回的 bool 值，如果有任何一个 bool 值为 True，外层的 any 就返回 True。\",\"is_gameover 函数用来判断游戏是否结束。当上下左右四个方向都不能移动时，游戏结束。\"]},\"18\":{\"h\":\"判断能否移动\",\"t\":[\"def move_is_possible(self, direction): '''传入要移动的方向 判断能否向这个方向移动 ''' def row_is_left_movable(row): '''判断一行里面能否有元素进行左移动或合并 ''' def change(i): # 当左边有空位（0），右边有数字时，可以向左移动 if row[i] == 0 and row[i + 1] != 0: return True # 当左边有一个数和右边的数相等时，可以向左合并 if row[i] != 0 and row[i + 1] == row[i]: return True return False return any(change(i) for i in range(len(row) - 1)) # 检查能否移动（合并也可以看作是在移动） check = {} # 判断矩阵每一行有没有可以左移动的元素 check['Left'] = lambda field: any(row_is_left_movable(row) for row in field) # 判断矩阵每一行有没有可以右移动的元素。这里只用进行判断，所以矩阵变换之后，不用再变换复原 check['Right'] = lambda field: check['Left'](invert(field)) check['Up'] = lambda field: check['Left'](transpose(field)) check['Down'] = lambda field: check['Right'](transpose(field)) # 如果 direction 是“左右上下”即字典 check 中存在的操作，那就执行它对应的函数 if direction in check: # 传入矩阵，执行对应函数 return check[direction](self.field) else: return False\",\"在 move_is_possible 函数中，我们只用实现判断能否向左移动的代码，然后同样利用矩阵的转置和逆转来转换矩阵，完成能否向其他方向移动的判断。\"]},\"19\":{\"h\":\"绘制游戏界面\",\"t\":[\"（注：这一步是在棋盘类内定义的）\",\"def draw(self, screen): help_string1 = '(W)Up (S)Down (A)Left (D)Right' help_string2 = ' (R)Restart (Q)Exit' gameover_string = ' GAME OVER' win_string = ' YOU WIN!' # 绘制函数 def cast(string): # addstr() 方法将传入的内容展示到终端 screen.addstr(string + '\\\\n') # 绘制水平分割线的函数 def draw_hor_separator(): line = '+' + ('+------' * self.width + '+')[1:] cast(line) # 绘制竖直分割线的函数 def draw_row(row): cast(''.join('|{: ^5} '.format(num) if num > 0 else '| ' for num in row) + '|') # 清空屏幕 screen.clear() # 绘制分数和最高分 cast('SCORE: ' + str(self.score)) if 0 != self.highscore: cast('HIGHSCORE: ' + str(self.highscore)) # 绘制行列边框分割线 for row in self.field: draw_hor_separator() draw_row(row) draw_hor_separator() # 绘制提示文字 if self.is_win(): cast(win_string) else: if self.is_gameover(): cast(gameover_string) else: cast(help_string1) cast(help_string2)\",\"这部分代码的关键在于 cast 函数。在 draw 函数传入的 screen 参数表示绘画的窗体对象，这里我们先记住 screen.addstr() 的作用是绘制字符，screen.clear() 的作用是清空屏幕，达到刷新的目的。在下一部分主逻辑后面，我们再结合两部分内容来理解 curses 库的用法。\"]},\"20\":{\"h\":\"完成主逻辑\",\"t\":[\"完成以上工作后，我们就可以补完主逻辑了！\",\"def main(stdscr): def init(): # 重置游戏棋盘 game_field.reset() return 'Game' def not_game(state): # 根据状态画出游戏的界面 game_field.draw(stdscr) # 读取用户输入得到 action，判断是重启游戏还是结束游戏 action = get_user_action(stdscr) # 如果没有 'Restart' 和 'Exit' 的 action，将一直保持现有状态 responses = defaultdict(lambda: state) responses['Restart'], responses['Exit'] = 'Init', 'Exit' return responses[action] def game(): # 根据状态画出游戏的界面 game_field.draw(stdscr) # 读取用户输入得到 action action = get_user_action(stdscr) if action == 'Restart': return 'Init' if action == 'Exit': return 'Exit' if game_field.move(action): # move successful if game_field.is_win(): return 'Win' if game_field.is_gameover(): return 'Gameover' return 'Game' state_actions = { 'Init': init, 'Win': lambda: not_game('Win'), 'Gameover': lambda: not_game('Gameover'), 'Game': game } # 使用颜色配置默认值 curses.use_default_colors() # 实例化游戏界面对象并设置游戏获胜条件为 2048 game_field = GameField(win=2048) state = 'Init' # 状态机开始循环 while state != 'Exit': state = state_actions[state]() curses.wrapper(main)\",\"这里的主要内容在实验的开始就分析过了。 所以我们来结合上一部分出现的 screen.addstr() 和 screen.clear() 理解 curses 库的用法。\",\"首先， curses.wrapper 函数会激活并初始化终端进入 'curses 模式'。 在这个模式下会禁止输入的字符显示在终端上、禁止终端程序的行缓冲（line buffering），即字符在输入时就可以使用，不需要遇到换行符或回车。\",\"接着，curses.wrapper 函数需要传一个函数作为参数，这个传进去的函数必须满足第一个参数为主窗体（main window） stdscr。 在前面的代码里，可以看到我们给 curses.wrapper(main) 的 main 函数中传入了一个 stdscr。\",\"最后，stdscr 作为 window.addstr(str)、window.clear() 方法的调用需要窗体对象（window object），在 game_field.draw(stdscr) 中传入 draw 方法中。\"]},\"21\":{\"h\":\"运行\",\"t\":[\"前面顺顺利利，偏偏到运行这一步出了问题（好像前面也不太可能出问题，都是写代码）。查了一下百度，好像是因为curses库只支持linux。然后去下载了一个支持win的第三方版本，最后成功运行了！\",\"2.8-1\",\"（其实并没有完美运行，某些操作会导致程序报错）\"]},\"22\":{\"h\":\"面向对象重构\"},\"23\":{\"h\":\"Action类\",\"t\":[\"体现面向对象的编程方法，实现的Action类可以对于每个窗体实现操作。\",\"class Action(object): UP = 'up' LEFT = 'left' DOWN = 'down' RIGHT = 'right' RESTART = 'restart' EXIT = 'exit' actions = [UP, LEFT, DOWN, RIGHT, RESTART, EXIT] letter_codes = [ord(ch) for ch in 'WASDRQwasdrq'] actions_dict = dict(zip(letter_codes, actions)) def init(self, stdscr): self.stdscr = stdscr def get(self): char = \\\"N\\\" while char not in self.actions_dict: char = self.stdscr.getch() return self.actions_dict[char]\"]},\"24\":{\"h\":\"Grid类\",\"t\":[\"Grid类包含所有对于格子计算的操作，包括上下左右移动和重新开始。\"]},\"25\":{\"h\":\"reset\",\"t\":[\"将整个棋盘重置，变成空棋盘后加入两个随机方块。\",\"# 重新开始和清零 def reset(self): self.cells = [[0 for i in range(self.size)] for j in range(self.size)] self.add_random_item() self.add_random_item()\"]},\"26\":{\"h\":\"add_random_item\",\"t\":[\"添加随机方块，可能为2或4\",\"# 每次操作加入随机两个方块，可能是2 或4 def add_random_item(self): empty_cells = [(i, j) for i in range(self.size) for j in range(self.size) if self.cells[i][j] == 0] (i, j) = random.choice(empty_cells) self.cells[i][j] = 4 if random.randrange(100) >= 90 else 2\"]},\"27\":{\"h\":\"transpose\",\"t\":[\"# 矩阵转置 def transpose(self): self.cells = [list(row) for row in zip(*self.cells)]\"]},\"28\":{\"h\":\"invert\",\"t\":[\"# 矩阵翻转 def invert(self): self.cells = [row[::-1] for row in self.cells]\"]},\"29\":{\"h\":\"move_row_left\",\"t\":[\"将矩阵向左划，计算方块的数值\"]},\"30\":{\"h\":\"tighten\",\"t\":[\"矩阵向左收紧\",\"# 将矩阵向左收缩 def tighten(row): new_row = [i for i in row if i != 0] new_row += [0 for i in range(len(row) - len(new_row))] return new_row\"]},\"31\":{\"h\":\"merge\",\"t\":[\"将相邻的两个数值相同的格子合并\",\"# 将相邻的两个数值相同的方格合并 def merge(row): pair = False new_row = [] for i in range(len(row)): if pair: new_row.append(2 * row[i]) #self.score += 2 * row[i] pair = False else: if i + 1 < len(row) and row[i] == row[i + 1]: pair = True new_row.append(0) else: new_row.append(row[i]) assert len(new_row) == len(row) return new_row\",\"返回\",\"# 先向左收缩然后合并然后再向左收缩完成一次操作 return tighten(merge(tighten(row)))\"]},\"32\":{\"h\":\"move_left\",\"t\":[\"# 向左划 def move_left(self): self.cells = [self.move_row_left(row) for row in self.cells]\"]},\"33\":{\"h\":\"move_right\",\"t\":[\"# 向右划 def move_right(self): self.invert() self.move_left() self.invert()\"]},\"34\":{\"h\":\"move_up\",\"t\":[\"# 向上划 def move_up(self): self.transpose() self.move_left() self.transpose()\"]},\"35\":{\"h\":\"move_down\",\"t\":[\"# 向下划 def move_down(self): self.transpose() self.move_right() self.transpose()\"]},\"36\":{\"h\":\"row_can_move_left\",\"t\":[\"判断能不能向左移动\",\"# 判断能否向左划 @staticmethod def row_can_move_left(row): def change(i): if row[i] == 0 and row[i + 1] != 0: return True if row[i] != 0 and row[i + 1] == row[i]: return True return False return any(change(i) for i in range(len(row) - 1))\"]},\"37\":{\"h\":\"can_move_left\",\"t\":[\"def can_move_left(self): return any(self.row_can_move_left(row) for row in self.cells)\"]},\"38\":{\"h\":\"can_move_right\",\"t\":[\" def can_move_right(self): self.invert() can = self.can_move_left() self.invert() return can\"]},\"39\":{\"h\":\"can_move_up\",\"t\":[\"def can_move_up(self): self.transpose(); can = self.can_move_left() self.transpose() return can\"]},\"40\":{\"h\":\"can_move_down\",\"t\":[\"def can_move_down(self): self.transpose() can = self.can_move_right() self.transpose() return can\",\"所有代码：\",\"class Grid(object): # 初始化函数 def __init__(self, size): self.size = size self.cells = None self.reset() # 重新开始和清零 def reset(self): self.cells = [[0 for i in range(self.size)] for j in range(self.size)] self.add_random_item() self.add_random_item() # 每次操作加入随机两个方块，可能是2 或4 def add_random_item(self): empty_cells = [(i, j) for i in range(self.size) for j in range(self.size) if self.cells[i][j] == 0] (i, j) = random.choice(empty_cells) self.cells[i][j] = 4 if random.randrange(100) >= 90 else 2 # 矩阵转置 def transpose(self): self.cells = [list(row) for row in zip(*self.cells)] # 矩阵翻转 def invert(self): self.cells = [row[::-1] for row in self.cells] # 向左划 @staticmethod def move_row_left(row): # 将矩阵向左收缩 def tighten(row): new_row = [i for i in row if i != 0] new_row += [0 for i in range(len(row) - len(new_row))] return new_row # 将相邻的两个数值相同的方格合并 def merge(row): pair = False new_row = [] for i in range(len(row)): if pair: new_row.append(2 * row[i]) #self.score += 2 * row[i] pair = False else: if i + 1 < len(row) and row[i] == row[i + 1]: pair = True new_row.append(0) else: new_row.append(row[i]) assert len(new_row) == len(row) return new_row # 先向左收缩然后合并然后再向左收缩完成一次操作 return tighten(merge(tighten(row))) # 向左划 def move_left(self): self.cells = [self.move_row_left(row) for row in self.cells] # 向右划 def move_right(self): self.invert() self.move_left() self.invert() # 向上划 def move_up(self): self.transpose() self.move_left() self.transpose() # 向下划 def move_down(self): self.transpose() self.move_right() self.transpose() # 判断能否向左划 @staticmethod def row_can_move_left(row): def change(i): if row[i] == 0 and row[i + 1] != 0: return True if row[i] != 0 and row[i + 1] == row[i]: return True return False return any(change(i) for i in range(len(row) - 1)) def can_move_left(self): return any(self.row_can_move_left(row) for row in self.cells) def can_move_right(self): self.invert() can = self.can_move_left() self.invert() return can def can_move_up(self): self.transpose(); can = self.can_move_left() self.transpose() return can def can_move_down(self): self.transpose() can = self.can_move_right() self.transpose() return can\"]},\"41\":{\"h\":\"Screen类\",\"t\":[\"Screen类用来绘制游戏界面，包括棋盘和方块数值，以及分数。\",\"提示文字\",\"help_string1 = '(W)up (S)down (A)left (D)right' help_string2 = ' (R)Restart (Q)Exit' over_string = ' GAME OVER' win_string = ' YOU WIN!'\"]},\"42\":{\"h\":\"cast\",\"t\":[\"def cast(self, string): self.screen.addstr(string + '\\\\n')\"]},\"43\":{\"h\":\"draw_row\",\"t\":[\"画格子的竖线\",\"def draw_row(self, row): self.cast(''.join('|{: ^5}'.format(num) if num > 0 else '| ' for num in row) + '|')\"]},\"44\":{\"h\":\"draw\",\"t\":[\"画格子的横线和文字数字\",\"def draw(self): self.screen.clear() self.cast('SCORE: ' + str(self.score)) for row in self.grid.cells: self.cast('+-----' * self.grid.size + '+') self.draw_row(row) self.cast('+-----' * self.grid.size + '+') if self.win: self.cast(self.win_string) else: if self.over: self.cast(self.over_string) else: self.cast(self.help_string1) self.cast(self.help_string2)\",\"所有代码：\",\"class Screen(object): help_string1 = '(W)up (S)down (A)left (D)right' help_string2 = ' (R)Restart (Q)Exit' over_string = ' GAME OVER' win_string = ' YOU WIN!' def __init__(self, screen=None, grid=None, score=0, best_score=0, over=False, win=False): self.grid = grid self.score = score self.over = over self.win = win self.screen = screen self.counter = 0 def cast(self, string): self.screen.addstr(string + '\\\\n') def draw_row(self, row): self.cast(''.join('|{: ^5}'.format(num) if num > 0 else '| ' for num in row) + '|') def draw(self): self.screen.clear() self.cast('SCORE: ' + str(self.score)) for row in self.grid.cells: self.cast('+-----' * self.grid.size + '+') self.draw_row(row) self.cast('+-----' * self.grid.size + '+') if self.win: self.cast(self.win_string) else: if self.over: self.cast(self.over_string) else: self.cast(self.help_string1) self.cast(self.help_string2)\"]},\"45\":{\"h\":\"GameManager类\",\"t\":[\"运行游戏的主逻辑类，包括游戏运行的流程控制状态机。\"]},\"46\":{\"h\":\"reset\",\"t\":[\"重置游戏，全部重新开始，将所有数值全部回归初始状态。\",\"def reset(self): self.state = 'init' self.win = False self.over = False self.score = 0 self.grid = Grid(self.size) self.grid.reset()\"]},\"47\":{\"h\":\"screen\",\"t\":[\"显示游戏画面，刷新画面\",\"@property def screen(self): return Screen(screen=self.stdscr, score=self.score, grid=self.grid, win=self.win, over=self.over)\"]},\"48\":{\"h\":\"move\",\"t\":[\"操作函数，获取action判断能否移动，如果能就执行移动。\",\"def move(self, direction): if self.can_move(direction): getattr(self.grid, 'move_' + direction)() self.grid.add_random_item() return True else: return False\"]},\"49\":{\"h\":\"is_win\",\"t\":[\"游戏获胜条件，判断游戏是否获胜（这里是有一个格子达到2048就算获胜），获胜则结束游戏。\",\"@property def is_win(self): self.win = max(chain(*self.grid.cells)) >= self.win_num return self.win\"]},\"50\":{\"h\":\"is_over\",\"t\":[\"游戏失败函数，如果没有可以移动的方向则游戏失败。\",\"@property def is_over(self): self.over = not any(self.can_move(move) for move in self.action.actions) return self.over\"]},\"51\":{\"h\":\"can_move\",\"t\":[\"判断是否可以移动函数，参数为一个方向，返回一个布尔值。\",\"def can_move(self, direction): return getattr(self.grid, 'can_move_' + direction)()\"]},\"52\":{\"h\":\"state_init\",\"t\":[\"状态重置\",\"def state_init(self): self.reset() return 'game'\"]},\"53\":{\"h\":\"state_game\",\"t\":[\"游戏状态机，控制游戏的重启和结束以及操作。\",\"def state_game(self): self.screen.draw() action = self.action.get() if action == Action.RESTART: return 'init' if action == Action.EXIT: return 'exit' if self.move(action): if self.is_win: return 'win' if self.is_over: return 'over' return 'game'\"]},\"54\":{\"h\":\"_restart_or_exit\",\"t\":[\"def _restart_or_exit(self): self.screen.draw() return 'init' if self.action.get() == Action.RESTART else 'exit'\"]},\"55\":{\"h\":\"state_win\",\"t\":[\" def state_win(self): return self._restart_or_exit()\"]},\"56\":{\"h\":\"state_over\",\"t\":[\"def state_over(self): return self._restart_or_exit()\"]},\"57\":{\"h\":\"__call__\",\"t\":[\"def __call__(self, stdscr): curses.use_default_colors() self.stdscr = stdscr self.action = Action(self.stdscr) while self.state != 'exit': self.state = getattr(self, 'state_' + self.state)()\"]},\"58\":{\"h\":\"河北省赛赛后反思\"},\"59\":{\"h\":\"前言\",\"t\":[\"这次比赛打的真是艰难，赛前封校封教学楼导致连个比赛场地都申请不下来，最后好不容易才把宿舍的自习室申请下来的当场地了。赛前热身赛直接爆零,主办方在到时间之后十五分钟都没有把我们的登录申请通过，后来通过了习题集却没有题，之后草草放上去了几道巨难的题，我们直接爆零。比赛之前我又把自己学生证搞丢了，开打的时候就很难受。只能说疫情当下，大家都挺不容易的，本来我们就是打星参赛，但是感觉这场打的很难受。\"]},\"60\":{\"h\":\"反思\",\"t\":[\"赛时A了4题，排名100整，自我感觉上感觉发挥的是比较差的。\",\"首先开局看错签到题耽误了时间，其实也还好那时候排名还在前五十，但b题签到最后没有写出来。这就很亏了。其实签到题是D题，zzh还是非常给力的，我连题还没读明白他就给A了。然后又看到H也是一个签到题，我们就一起顺手把它A了。之后一直卡壳，裁纸游戏耽误了很多时间，一开始想复杂了，认为它是个dp题，直到后来认真分析了数据范围和大小，然后我突然来了点灵感才把它A了😓。\",\"筷子这一题真的是集全队之力（主要是每个人好像都会但是每个人思路又不太一样），一开始是感觉这个题巨难，然后又发现很多队都写出来了，然后又发现好像也不难，但是意见不是很统一，最后zzh上手写，调了一阵，过不了。然后发现，这题TM卡cin！！！，我们因为这个wa了两发（其实也有可能是我们算法的时间复杂度有点高，但也是O(n)算法呀）。\",\"生日蛋糕那一题也就是B题应该是可以写出来的，最后看出来规律的了，但是时间不太够了，代码没写出来。很可惜啊😭。\",\"A题严重低估难度了。\",\"当一个队友开始决定去写大模拟的时候，你们队就从此少了一个人。\",\"直到还剩两个小时的时候还很乐观，感觉这道题只是工作量大了点。直到zzh写完试样例的时候才发觉这道题不是简单的大模拟，还加了dp的buff，这道题真的严重浪费了很多很多的时间。(zzh想写大模拟，真是九头牛都拉不回来😥)\",\"希望以后写题之前得认真看懂题，看漏了是真的害人。\"]},\"61\":{\"c\":[\"题目记录\",\"竞赛\"]},\"62\":{\"h\":\"刷题日记day1-Flip Game\",\"t\":[\"做某个题单的第一道题，虽然没什么难度，但是还是十分考验码代码的能力的（很容易写出bug），不过还好，这次写的还是很顺利的。\"]},\"63\":{\"c\":[\"题目记录\",\"题单\"]},\"64\":{\"h\":\"刷题日记day10-Currency Exchange\",\"t\":[\"开始做图论的题了，第一天就有点难，贝尔曼福特算法已经忘光光了。\",\"今天去和lxc他们玩了一晚上桌游，很开心捏😘\"]},\"65\":{\"h\":\"刷题日记day11-Wormholes\",\"t\":[\"开始做图论的题的第二天，今天打icpc真难，不过还好手速快，过了三题，但是队伍排名还在800名左右，仰望hpy大佬。\",\"今天这一题做个简单的Floyd算法安慰一下我的心灵。\"]},\"66\":{\"h\":\"刷题日记day12-Balance\",\"t\":[\"今天做一道简单的dp题，因为临近CCPC省赛，根据往年的情况到时候大概率碰到很多dp题和数据结构，还有大模拟，所以加紧复习一下dp，虽然dp真的好难😂。\"]},\"67\":{\"h\":\"刷题日记day13-Cash Machine\",\"t\":[\"本来是一道简单的题，但是我忘了怎么做了，耽误了很多时间，麻了。\",\"今天跑了好几公里，感觉还行，至少比以前身体好点了。\"]},\"68\":{\"h\":\"刷题日记day14-The Cow Lexicon\",\"t\":[\"又是水题，但是我叕写了很长时间，ε=(´ο｀*)))唉，真是太粗心了，一直没debug出来，犯了很多低级错误。\"]},\"69\":{\"h\":\"刷题日记day15-Alignment\",\"t\":[\"最大上升子序列模板题。\"]},\"70\":{\"h\":\"刷题日记day16-Code\",\"t\":[\"纯纯的数学题，我是一点都不会啊，我就高中的数学水平，还真看不出来这是组合数。最后去网上找了体解才搞懂。呜呜呜~~~\"]},\"71\":{\"h\":\"刷题日记day2-The Pilots Brothers' refrigerator\",\"t\":[\"今天来开开心心的做第二道题喽。\"]},\"72\":{\"c\":[\"题目记录\",\"题单\"]},\"73\":{\"h\":\"刷题日记day3-Radar Installation\",\"t\":[\"今天被突然到来的一场icpc网络赛打蒙了，一下午罚坐了5个小时，现在腰还是痛的，简直就是坐大牢。\",\"今天练得题还是比较简单。\"]},\"74\":{\"c\":[\"题目记录\",\"题单\"]},\"75\":{\"h\":\"刷题日记day4-Power of Cryptography\",\"t\":[\"建议先看思路，再看代码，这题有亿点简单，但是容易想歪，比如说我。\",\"写之前千万别看评论区，不然评论区有答案就没意思了。\"]},\"76\":{\"h\":\"刷题日记day5-Y2K Accounting Bug\",\"t\":[\"今天做核酸，租空调，坐了某lxc的非主流摩托车，感觉摩托是真的爽。🚀\",\"这一题好像是关于千年虫病毒的吧（虽然题目和故事一点关系都没有😂）\"]},\"77\":{\"h\":\"刷题日记day6-Tautology\",\"t\":[\"电路真的好难，学不会了。不过今天新生来了还挺热闹的，回忆起了当初我刚来的时候。\",\"这道题挺简单的，如果没见过使用栈来进行运算的题，可以见识一下这道题。\"]},\"78\":{\"h\":\"刷题日记day7-Parencodings\",\"t\":[\"今天没什么新鲜事儿，只觉得很瞌睡😪，好无聊啊！😢\",\"买了几个挂钩，还想买把椅子。\",\"这个题数据量很小，很简单的题。\"]},\"79\":{\"h\":\"刷题日记day8-Crashing Robots\",\"t\":[\"今天第一次跑了六公里，累了个半死。给自己的手机买了个钢化膜，贴上后触控不灵敏了，好难受。不过这个膜才9块9，没有想象中的翘边，也挺好的，就是指纹解锁变慢了，上划返回桌面也不灵了，几次才能成功一次。\",\"这道题很简单，纯模拟。\"]},\"80\":{\"h\":\"刷题日记day9-Robot Motion\",\"t\":[\"今天斥巨资47元买了个好一点的枕头，pdd有的时候真的挺便宜的，不知道为啥，最近感觉自己觉醒了勤俭持家的本能，买什么都悠着点。\",\"这道题也很简单，大概是纯模拟。\"]},\"81\":{\"h\":\"算法笔记(一)单调队列\",\"t\":[\"这是第一次写算法笔记，可能自己的表达能力有限，所以标准就降低一些，只是留给以后的自己看。先前学习这个算法的时候一直搞不明白，去网上扒了很多篇文章去学，后来明白以后才发现这个算法也挺简单的。\"]},\"82\":{\"h\":\"单调队列\"},\"83\":{\"h\":\"定义\",\"t\":[\"单调队列顾名思义，就是构建一个队列，使这个队列保持单调性，定义很简单对吧？就是类似下面这样一个队列：\",\"img\",\"用windows画图简单画的，很简陋不要吐槽。\",\"就像排队一样从高到低排，但是如果想要加入这个队列就只能从队头或者队尾进入，这是队列的特性。这里推荐一下我在别人博客见到的一句话，特别形象。\",\"如果一个选手比你小还比你强，你就可以退役了。——单调队列\",\"好了，定义解释清楚了之后我们来看看这么个队列有个什么用。下面是一道标准的滑动窗口问题。\"]},\"84\":{\"h\":\"例题分析\",\"t\":[\"题目来源 ：acwing154.滑动窗口\",\"给定一个大小为 的数组。有一个大小为 的滑动窗口，它从数组的最左边移动到最右边。你只能在窗口中看到 个数字。每次滑动窗口向右移动一个位置。\",\"以下是一个例子：\",\"该数组为 [1 3 -1 -3 5 3 6 7]， 为 。\",\"窗口位置\",\"最小值\",\"最大值\",\"[1 3 -1] -3 5 3 6 7\",\"-1\",\"3\",\"1 [3 -1 -3] 5 3 6 7\",\"-3\",\"3\",\"1 3 [-1 -3 5] 3 6 7\",\"-3\",\"5\",\"1 3 -1 [-3 5 3] 6 7\",\"-3\",\"5\",\"1 3 -1 -3 [5 3 6] 7\",\"3\",\"6\",\"1 3 -1 -3 5 [3 6 7]\",\"3\",\"7\",\"你的任务是确定滑动窗口位于每个位置时，窗口中的最大值和最小值。\"]},\"85\":{\"h\":\"输入格式\",\"t\":[\"输入包含两行。\",\"第一行包含两个整数 n 和k ，分别代表数组长度和滑动窗口的长度。第二行有 n 个整数，代表数组的具体数值。同行数据之间用空格隔开。\"]},\"86\":{\"h\":\"输出格式\",\"t\":[\"输出包含两个。\",\"第一行输出，从左至右，每个位置滑动窗口中的最小值。\",\"第二行输出，从左至右，每个位置滑动窗口中的最大值。\"]},\"87\":{\"h\":\"输入样例：\",\"t\":[\"8 3 1 3 -1 -3 5 3 6 7\"]},\"88\":{\"h\":\"输出样例：\",\"t\":[\"-1 -3 -3 -3 3 3 3 3 5 5 6 7\",\"我们常人解决这个问题，很简单对吧，不过是看一眼找到方框里哪个最大哪个最小就行了，但是我们看一下数据范围， ,判题机的运行速度一般在每秒 次左右。假如我们采用最朴素的方式，每次方框向前移动一格，就扫描一遍方框，从中选出最小的和最大的值，这样的算法时间复杂度大概是 ,在这里也即 ，那么在这里是必然会超时的。所以由此得知我们只能选用时间复杂度在 一下的算法。\",\"当然如果你是大佬，使用线段树、ST表算法（时间复杂度 过也是可以的，不过在这里有点大材小用了。\",\"因为我们使用单调队列算法的时间复杂度只有 ！\",\"代码层面也相对于那些算法更好写。下面我们来讲具体怎么使用单调队列。\"]},\"89\":{\"h\":\"具体实现\",\"t\":[\"首先我们使用一个数组来模拟一个双向队列：\",\"int head, tail, q[1000001];//q是队列 void maxn() { head=1;tail=0;//记录队头和队尾 for(int i=1;i<=n;i++)//对数组中每个元素进行处理 { //code } }\",\"我们发现一个性质：如果队列中存在两个元素，满足 a[i]a[j] 且 i < j，那么无论在什么时候我们都不会取 a[i] 作为最大值了，所以可以直接将 a[i] 删掉（也就是上面我推荐那一句名言)。此时队列中剩下的元素严格单调递增，队头就是其中的最大值，立刻就能找到。\",\"先把找最大值的代码放出来，下面对样例进行详细分析\",\"int head,tail,q[1000001]; int p[1000001],k,n,a[1000001]; /* 1.p用来存储队列中元素在原数组中的序号 2.a是原数组 */ void maxn() { head=1;tail=0;//记录队头和队尾 for(int i=1;i<=n;i++) { //假如队列还未清空并且新的所要被处理的元素比队尾的元素大 //则队尾元素无可能是最大值，弹出队尾，一直循环 while(head<=tail&&q[tail]<=a[i]) --tail;//从队尾出队； q[++tail]=a[i];//入队； p[tail]=i;//记录在原序列位置 while(p[head]<=i-k)//长度不超过k； head++; //输出队头元素，即为最大值。 if(i>=k) printf(\\\"%d \\\",q[head]); } putchar('\\\\n'); }\",\"一开始队中没有一个元素，我们让1入队，此时，q={1},p={1}。\",\"然后轮到3，我们需要思考：如果把3放进去，3有没有可能成为队列中最大的元素，显然现在队列中只有1,3比1大，3只要进去就是最大值，所以把1弹出3入队，此时，q={3},p={2}。\",\"接下来是-1，显然它比队列中所有元素（也就是3）要小，但是也不能排除以后的元素都比它还要小，等到3出队后它成为最大值的可能，所以这次不弹出元素，-1入队，此时，q={3,-1},p={2,3}。\",\"接下来是-3，和-1同理，比队列中所有元素（也就是3和-1）要小，但是它很靠前，所以入队，此时，q={3,-1,-3},q={2,3,4}。\",\"接下来是5，这就不一样了，假如要让5入队，那队列就会变成**{3,-1,-3,5}，此时我们发现，3已经不是最大值了，并且中间的-1和-3也不可能成为最大值了，**因此为了保持队列的单调性，我们要将队列中的元素从队尾挨个和5比较，如果比5小就弹出，所以处理后3,-1,-3被弹出，此时只剩下了5，q={5},p={5}。\",\"以此类推。。。。。\",\"另外，我们还要关注一下序列长度的问题，假如队列的元素达到k，队头元素也就是最大的元素会弹出队列中第二大的元素会成为新的队头。\",\"上述是求最大值大代码，求最小值的代码同理。\",\"下面是完整代码\",\"#include<bits/stdc++.h> using namespace std; int head,tail,q[1000001]; int p[1000001],k,n,a[1000001]; inline void maxn() { head=1;tail=0; for(int i=1;i<=n;i++) { while(head<=tail&&q[tail]<=a[i]) --tail; q[++tail]=a[i]; p[tail]=i; while(p[head]<=i-k) head++; if(i>=k) cout << q[head] << \\\" \\\"; } cout << endl; } inline void minn() { head=1;tail=0; for(int i=1;i<=n;i++) { while(head<=tail&&q[tail]>=a[i]) --tail; q[++tail]=a[i]; p[tail]=i; while(p[head]<=i-k) head++; if(i>=k) cout << q[head] << \\\" \\\"; } cout << endl; } int main() { cin >> n >> k; for(int i=1;i<=n;i++) cin >> a[i]; minn(); maxn(); return 0; }\",\"参考文章：\",\"https://zhuanlan.zhihu.com/p/346354943\"]},\"90\":{\"h\":\"算法笔记(二)排序算法\"},\"91\":{\"h\":\"说在前面的话\",\"t\":[\"在网上经常见到一句程序员对新入行的新人说的话：\",\"不要重复造轮子（Stop Trying to Reinvent the Wheel）\",\"造轮子的意思就是重新编写别人实现过的代码，一般来说这样会效率低下，耗时耗力写出来的程序还不一定比别人的好。我每次看到这句话总会被莫名戳中笑点，也不知道笑点到底在哪个地方。\",\"不过总的来说这句话对于大部分程序员是对的，毕竟对于现在那些大型软件，不可能要求一个程序员就把它完整的编写出来，对程序进行封装和打包，进行模块化编程才是王道。这样没人负责一个模块，不仅效率高，bug也好找。但是我觉得对于新入行的程序员，自己学习造一些轮子还是有很多帮助的，去了解那些程序底层的实现原理有助于开拓自己的思维。\"]},\"92\":{\"h\":\"排序算法分类\",\"t\":[\"排序算法（Sorting algorithm）大概分为三类：\",\"简单排序算法：插入排序、冒泡排序、选择排序\",\"复杂排序算法：快速排序(yyds)、归并排序\",\"特殊排序算法：基数排序(简称：鸡排基排)、堆排序、桶排序\"]},\"93\":{\"h\":\"算法性质\"},\"94\":{\"h\":\"稳定性\",\"t\":[\"稳定性是指相等的元素经过排序之后相对顺序是否发生了改变。\",\"拥有稳定性这一特性的算法会让原本有相等键值的纪录维持相对次序，即如果一个排序算法是稳定的，当有两个相等键值的纪录R和S，且在原本的列表中R出现在S之前，在排序过的列表中R也将会是在S之前。摘自OI Wiki\"]},\"95\":{\"h\":\"时间复杂度\",\"t\":[\"时间复杂度是定性描述算法的运行时间，不包括这个函数的低阶项和首项系数。\"]},\"96\":{\"h\":\"排序算法分析\"},\"97\":{\"h\":\"简单排序算法\"},\"98\":{\"h\":\"选择排序\",\"t\":[\"选择排序（Selection sort）是一种简单直观的排序算法。\",\"**原理：**每次遍历数组找出第i小的数然后与第i位交换位置。\",\"性质\",\"稳定性：由于swap函数的存在，选择排序是一种不稳定的算法。\",\"时间复杂度：稳定时间复杂度$O(n^2)$\",\"代码\",\"// C++ version void selection_sort(int* a, int n) { for (int i = 1; i < n; i++) { int min_num = i; for (int j = i + 1; j <= n; j++) { if (a[j] < a[min_num]) { min_num = j; } } std::swap(a[i], a[min_num]); } }\"]},\"99\":{\"h\":\"冒泡排序\",\"t\":[\"冒泡排序（Bubble sort）是一种简单直观的排序算法，执行过程中仿佛气泡一样，逐渐小的数飘到最前面，大的数冒到最后面。\",\"**原理：**每次检查相邻两个元素，如果逆序就交换这两个元素，直到数列有序。\",\"性质\",\"稳定性：冒泡排序很稳定。\",\"时间复杂度： \",\"最好情况：数列有序，只需检查一遍数组，时间复杂度$O(n)$\",\"最坏情况：时间复杂度为$O(n^2)$\",\"平均情况：时间复杂度为$O(n^2)$\",\"代码\",\"// C++ version void bubble_sort(int* a, int n) { bool flag = true; while (flag) { flag = false; for (int i = 1; i < n; i++) { if (a[i] > a[i + 1]) { flag = true; std::swap(a[i], a[i + 1]); } } } }\"]},\"100\":{\"h\":\"插入排序\",\"t\":[\"插入排序（Insertion sort）是一种简单直观的排序算法，就像打poker整理手牌一样。\",\"**原理：**将数组中的元素分为已排序和未排序两部分，每次将未排序中的一个元素插入到已排序的元素中正确的位置。\",\"性质\",\"稳定性：插入排序很稳定。\",\"时间复杂度： \",\"最好情况：数列有序，只需检查一遍数组，时间复杂度$O(n)$\",\"最坏情况：时间复杂度为$O(n^2)$\",\"平均情况：时间复杂度为$O(n^2)$\",\"代码\",\"// C++ Version void insertion_sort(int* a, int n) { // 对 a[1],a[2],...,a[n] 进行插入排序 for (int i = 2; i <= n; ++i) { int key = a[i]; int j = i - 1; while (j > 0 && a[j] > key) { a[j + 1] = a[j]; j--; } a[j + 1] = key; } }\"]},\"101\":{\"h\":\"复杂排序算法\"},\"102\":{\"h\":\"快速排序\",\"t\":[\"快速排序（Quicksort），又称分区交换排序（partition-exchange sort），简称快排，是一种被广泛运用的排序算法。\",\"原理：\",\"快速排序分为三个过程：\",\"将数列划分为两部分（要求保证相对大小关系）；\",\"递归到两个子序列中分别进行快速排序；\",\"不用合并，因为此时数列已经完全有序。\",\"和归并排序不同，第一步并不是直接分成前后两个序列，而是在分的过程中要保证相对大小关系。具体来说，第一步要是要把数列分成两个部分，然后保证前一个子数列中的数都小于后一个子数列中的数。为了保证平均时间复杂度，一般是随机选择一个数 来当做两个子数列的分界。\",\"之后，维护一前一后两个指针 和 ，依次考虑当前的数是否放在了应该放的位置（前还是后）。如果当前的数没放对，比如说如果后面的指针 遇到了一个比 小的数，那么可以交换 和 位置上的数，再把 向后移一位。当前的数的位置全放对后，再移动指针继续处理，直到两个指针相遇。\",\"其实，快速排序没有指定应如何具体实现第一步，不论是选择 的过程还是划分的过程，都有不止一种实现方法。\",\"第三步中的序列已经分别有序且第一个序列中的数都小于第二个数，所以直接拼接起来就好了。\"]},\"103\":{\"h\":\"归并排序\"},\"104\":{\"h\":\"特殊排序算法\"},\"105\":{\"h\":\"基数排序\"},\"106\":{\"h\":\"堆排序\"},\"107\":{\"h\":\"桶排序\"},\"108\":{\"h\":\"Java实现模拟栈\",\"t\":[\"这几天除了要准备CCPC，还参加了一个蓝桥云课的小比赛。一般这种小比赛都是没人参加的，我也不会管它，也没证书、也没用，但是，上次我因为无聊参加了它的那个python比赛，那一场打的真的难，因为都是我不擅长的领域，各种技术应用，各种库的调用，我没学过都是一个一个去网上搜😂。虽然难，但是那一场比赛我真的学到了很多实用的东西，感觉比我自己半个月学的都多。话不多说有时间再好好聊聊。\"]},\"109\":{\"h\":\"栈\",\"t\":[\"**栈（stack）**又名堆栈，它是一种运算受限的线性表。限定仅在表尾进行插入和删除操作的线性表。这一端被称为栈顶，相对地，把另一端称为栈底。向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。\",\"^以上是百度百科的解释，总而言之，栈就像一个桶，每次往里放东西都会摞在最上面，每次从里面拿东西也只能从最上面拿，是一个先进后出的数据结构。\"]},\"110\":{\"h\":\"Java实现\",\"t\":[\"这里使用数组实现模拟栈。\",\"首先定义一个ArrayStack 类，里面需要一个数组datas来存储所有数据，然后arraysize 用来记录目前栈占用的大小，size 记录目前栈中的元素个数。\",\"import java.util.Arrays; public class ArrayStack<T> { private Object[] datas; private int size, arraySize; }\",\"栈一般有五种操作：\",\"判断是否为空：isEmpty()\",\"压栈：push()\",\"弹出：pop()\",\"获取栈顶元素：top()\",\"获取栈中元素个数：size()\"]},\"111\":{\"h\":\"代码\",\"t\":[\"import java.util.Arrays; public class ArrayStack<T> { private Object[] datas; private int size, arraySize; public ArrayStack() { // 构造方法，默认栈的大小为2 this.datas = new Object[2]; this.size = 0; this.arraySize = 2; } public boolean isEmpty() { // 判断栈是否为空 if (this.size == 0) {return true;} else {return false;} } public void push(T value) { // 压栈 // 栈满了，把栈的空间扩至原先的两倍大 if (this.size == this.arraySize) { this.datas = Arrays.copyOf(this.datas, 2 * this.arraySize); this.arraySize *= 2; } this.datas[this.size++] = value; } public T pop() { // 弹出栈顶元素并返回元素值 // 栈为空无法弹出，返回null if (this.size == 0) {return null;} this.size--; return (T) this.datas[this.size]; } public T top() { // 返回栈顶元素 // 栈为空返回null if (this.size == 0) {return null;} return (T) this.datas[this.size - 1]; } public int size() { // 返回栈中元素个数 return this.size; } }\"]},\"112\":{\"h\":\"C++中的this\",\"t\":[\"定义 ：this 是C++中的一个关键字，它是一个const指针，指向当前对象，通过它可以访问当前对象的所有成员。\",\"就像大多数面向对象的编程语言一样，this是为了方便访问对象的成员变量而设置的。在大多数情况下，this省略也没有影响，但是为了规范和安全还是建议在访问对象成员变量时加上this。\",\"像下面这个例子：\",\"此文章暂时咕咕咕咕\"]},\"113\":{\"h\":\"\",\"t\":[\"404 Not Found\"]},\"114\":{\"h\":\"Life\"},\"115\":{\"h\":\"Projects\"},\"116\":{\"h\":\"Contest\"},\"117\":{\"h\":\"Coding Training\"},\"118\":{\"h\":\"Training\"},\"119\":{\"h\":\"Algorithm\"},\"120\":{\"h\":\"Notes\"},\"121\":{\"h\":\"Data Structure\"},\"122\":{\"h\":\"Explore\"}},\"dirtCount\":0,\"index\":[[\"此文章暂时咕咕咕咕\",{\"1\":{\"112\":1}}],[\"此时只剩下了5\",{\"1\":{\"89\":1}}],[\"此时我们发现\",{\"1\":{\"89\":1}}],[\"此时\",{\"1\":{\"89\":4}}],[\"此时队列中剩下的元素严格单调递增\",{\"1\":{\"89\":1}}],[\"像下面这个例子\",{\"1\":{\"112\":1}}],[\"通过它可以访问当前对象的所有成员\",{\"1\":{\"112\":1}}],[\"通过对矩阵进行转置与逆转\",{\"1\":{\"16\":1}}],[\"指向当前对象\",{\"1\":{\"112\":1}}],[\"默认栈的大小为2\",{\"1\":{\"111\":1}}],[\"默认是最经典的\",{\"1\":{\"10\":1}}],[\"构造方法\",{\"1\":{\"111\":1}}],[\"弹出栈顶元素并返回元素值\",{\"1\":{\"111\":1}}],[\"弹出\",{\"1\":{\"110\":1}}],[\"弹出队尾\",{\"1\":{\"89\":1}}],[\"压栈\",{\"1\":{\"110\":1,\"111\":1}}],[\"类\",{\"1\":{\"110\":1}}],[\"类型\",{\"1\":{\"8\":1}}],[\"总而言之\",{\"1\":{\"109\":1}}],[\"^以上是百度百科的解释\",{\"1\":{\"109\":1}}],[\"^5\",{\"1\":{\"19\":1,\"43\":1,\"44\":1}}],[\"入栈或压栈\",{\"1\":{\"109\":1}}],[\"入队\",{\"1\":{\"89\":1}}],[\"相对地\",{\"1\":{\"109\":1}}],[\"相比上次真是飞跃的进步\",{\"1\":{\"0\":1}}],[\"限定仅在表尾进行插入和删除操作的线性表\",{\"1\":{\"109\":1}}],[\"栈为空返回null\",{\"1\":{\"111\":1}}],[\"栈为空无法弹出\",{\"1\":{\"111\":1}}],[\"栈满了\",{\"1\":{\"111\":1}}],[\"栈一般有五种操作\",{\"1\":{\"110\":1}}],[\"栈就像一个桶\",{\"1\":{\"109\":1}}],[\"栈\",{\"0\":{\"109\":1},\"1\":{\"109\":1}}],[\"话不多说有时间再好好聊聊\",{\"1\":{\"108\":1}}],[\"各种库的调用\",{\"1\":{\"108\":1}}],[\"各种技术应用\",{\"1\":{\"108\":1}}],[\"都有不止一种实现方法\",{\"1\":{\"102\":1}}],[\"都是写代码\",{\"1\":{\"21\":1}}],[\"再移动指针继续处理\",{\"1\":{\"102\":1}}],[\"再把\",{\"1\":{\"102\":1}}],[\"再看代码\",{\"1\":{\"75\":1}}],[\"位置上的数\",{\"1\":{\"102\":1}}],[\"小的数\",{\"1\":{\"102\":1}}],[\"遇到了一个比\",{\"1\":{\"102\":1}}],[\"依次考虑当前的数是否放在了应该放的位置\",{\"1\":{\"102\":1}}],[\"维护一前一后两个指针\",{\"1\":{\"102\":1}}],[\"来当做两个子数列的分界\",{\"1\":{\"102\":1}}],[\"来取\",{\"1\":{\"8\":1}}],[\"具体来说\",{\"1\":{\"102\":1}}],[\"具体实现\",{\"0\":{\"89\":1}}],[\"而是在分的过程中要保证相对大小关系\",{\"1\":{\"102\":1}}],[\"而且如果明年拿不到奖牌\",{\"1\":{\"2\":1}}],[\"而且有免费的饭菜\",{\"1\":{\"2\":1}}],[\"递归到两个子序列中分别进行快速排序\",{\"1\":{\"102\":1}}],[\"要求保证相对大小关系\",{\"1\":{\"102\":1}}],[\"要小\",{\"1\":{\"89\":2}}],[\"进行插入排序\",{\"1\":{\"100\":1}}],[\"进行模块化编程才是王道\",{\"1\":{\"91\":1}}],[\"平均情况\",{\"1\":{\"99\":1,\"100\":1}}],[\"平时正常上课的时候我也认为去教室上课不如自学\",{\"1\":{\"2\":1}}],[\"数列有序\",{\"1\":{\"99\":1,\"100\":1}}],[\"数值\",{\"1\":{\"7\":1}}],[\"逐渐小的数飘到最前面\",{\"1\":{\"99\":1}}],[\"执行过程中仿佛气泡一样\",{\"1\":{\"99\":1}}],[\"执行对应函数\",{\"1\":{\"18\":1}}],[\"$\",{\"1\":{\"98\":1,\"99\":3,\"100\":3}}],[\"稳定时间复杂度$o\",{\"1\":{\"98\":1}}],[\"稳定性是指相等的元素经过排序之后相对顺序是否发生了改变\",{\"1\":{\"94\":1}}],[\"稳定性\",{\"0\":{\"94\":1},\"1\":{\"98\":1,\"99\":1,\"100\":1}}],[\"由于swap函数的存在\",{\"1\":{\"98\":1}}],[\"性质\",{\"1\":{\"98\":1,\"99\":1,\"100\":1}}],[\"原理\",{\"1\":{\"98\":1,\"99\":1,\"100\":1,\"102\":1}}],[\"摘自oi\",{\"1\":{\"94\":1}}],[\"拥有稳定性这一特性的算法会让原本有相等键值的纪录维持相对次序\",{\"1\":{\"94\":1}}],[\"拥有自己的小站并且可以在上面发布自己的文章\",{\"1\":{\"0\":1}}],[\"桶排序\",{\"0\":{\"107\":1},\"1\":{\"92\":1}}],[\"堆排序\",{\"0\":{\"106\":1},\"1\":{\"92\":1}}],[\"鸡排基排\",{\"1\":{\"92\":1}}],[\"特殊排序算法\",{\"0\":{\"104\":1},\"1\":{\"92\":1}}],[\"特别形象\",{\"1\":{\"83\":1}}],[\"归并排序\",{\"0\":{\"103\":1},\"1\":{\"92\":1}}],[\"快速排序没有指定应如何具体实现第一步\",{\"1\":{\"102\":1}}],[\"快速排序分为三个过程\",{\"1\":{\"102\":1}}],[\"快速排序\",{\"0\":{\"102\":1},\"1\":{\"92\":1,\"102\":1}}],[\"复杂排序算法\",{\"0\":{\"101\":1},\"1\":{\"92\":1}}],[\"选择排序是一种不稳定的算法\",{\"1\":{\"98\":1}}],[\"选择排序\",{\"0\":{\"98\":1},\"1\":{\"92\":1,\"98\":1}}],[\"选错了方向可能努力也没什么结果\",{\"1\":{\"2\":1}}],[\"冒泡排序很稳定\",{\"1\":{\"99\":1}}],[\"冒泡排序\",{\"0\":{\"99\":1},\"1\":{\"92\":1,\"99\":1}}],[\"插入排序很稳定\",{\"1\":{\"100\":1}}],[\"插入排序\",{\"0\":{\"100\":1},\"1\":{\"92\":1,\"100\":1}}],[\"简称快排\",{\"1\":{\"102\":1}}],[\"简称\",{\"1\":{\"92\":1}}],[\"简单排序算法\",{\"0\":{\"97\":1},\"1\":{\"92\":1}}],[\"简直就是坐大牢\",{\"1\":{\"73\":1}}],[\"去了解那些程序底层的实现原理有助于开拓自己的思维\",{\"1\":{\"91\":1}}],[\"去网上扒了很多篇文章去学\",{\"1\":{\"81\":1}}],[\"毕竟对于现在那些大型软件\",{\"1\":{\"91\":1}}],[\"毕竟大学上网课\",{\"1\":{\"2\":1}}],[\"耗时耗力写出来的程序还不一定比别人的好\",{\"1\":{\"91\":1}}],[\"造轮子的意思就是重新编写别人实现过的代码\",{\"1\":{\"91\":1}}],[\"说在前面的话\",{\"0\":{\"91\":1}}],[\"排序算法分析\",{\"0\":{\"96\":1}}],[\"排序算法分类\",{\"0\":{\"92\":1}}],[\"排序算法\",{\"0\":{\"90\":1},\"1\":{\"92\":1}}],[\"排名100整\",{\"1\":{\"60\":1}}],[\"二\",{\"0\":{\"90\":1}}],[\"参考文章\",{\"1\":{\"89\":1}}],[\"参数为一个方向\",{\"1\":{\"51\":1}}],[\"参数表示绘画的窗体对象\",{\"1\":{\"19\":1}}],[\"参数是\",{\"1\":{\"8\":1}}],[\"求最小值的代码同理\",{\"1\":{\"89\":1}}],[\"队头元素也就是最大的元素会弹出队列中第二大的元素会成为新的队头\",{\"1\":{\"89\":1}}],[\"队头就是其中的最大值\",{\"1\":{\"89\":1}}],[\"另外\",{\"1\":{\"89\":1}}],[\"并且中间的\",{\"1\":{\"89\":1}}],[\"并在列表生成式中将二维数组变成一个以\",{\"1\":{\"12\":1}}],[\"并在这个位置上随机生成一个\",{\"1\":{\"12\":1}}],[\"显然它比队列中所有元素\",{\"1\":{\"89\":1}}],[\"显然现在队列中只有1\",{\"1\":{\"89\":1}}],[\"显示游戏画面\",{\"1\":{\"47\":1}}],[\"即如果一个排序算法是稳定的\",{\"1\":{\"94\":1}}],[\"即为最大值\",{\"1\":{\"89\":1}}],[\"即字符在输入时就可以使用\",{\"1\":{\"20\":1}}],[\"即字典\",{\"1\":{\"18\":1}}],[\"长度不超过k\",{\"1\":{\"89\":1}}],[\"记录目前栈中的元素个数\",{\"1\":{\"110\":1}}],[\"记录在原序列位置\",{\"1\":{\"89\":1}}],[\"记录队头和队尾\",{\"1\":{\"89\":2}}],[\"则队尾元素无可能是最大值\",{\"1\":{\"89\":1}}],[\"假如队列的元素达到k\",{\"1\":{\"89\":1}}],[\"假如队列还未清空并且新的所要被处理的元素比队尾的元素大\",{\"1\":{\"89\":1}}],[\"假如要让5入队\",{\"1\":{\"89\":1}}],[\"假如我们采用最朴素的方式\",{\"1\":{\"88\":1}}],[\"k\",{\"1\":{\"89\":6}}],[\"keyboard\",{\"1\":{\"9\":2}}],[\"keyaction\",{\"1\":{\"8\":1}}],[\"key\",{\"1\":{\"5\":1,\"8\":3,\"16\":3,\"100\":3}}],[\"立刻就能找到\",{\"1\":{\"89\":1}}],[\"删掉\",{\"1\":{\"89\":1}}],[\"且在原本的列表中r出现在s之前\",{\"1\":{\"94\":1}}],[\"且\",{\"1\":{\"89\":1}}],[\"满足\",{\"1\":{\"89\":1}}],[\"version\",{\"1\":{\"98\":1,\"99\":1,\"100\":1}}],[\"void\",{\"1\":{\"89\":4,\"98\":1,\"99\":1,\"100\":1,\"111\":1}}],[\"valuestate\",{\"1\":{\"8\":1}}],[\"value\",{\"1\":{\"5\":1,\"8\":3,\"10\":1,\"17\":3,\"111\":2}}],[\"时间复杂度为$o\",{\"1\":{\"99\":2,\"100\":2}}],[\"时间复杂度$o\",{\"1\":{\"99\":1,\"100\":1}}],[\"时间复杂度是定性描述算法的运行时间\",{\"1\":{\"95\":1}}],[\"时间复杂度\",{\"0\":{\"95\":1},\"1\":{\"88\":1,\"98\":1,\"99\":1,\"100\":1}}],[\"时会执行\",{\"1\":{\"8\":1}}],[\"次左右\",{\"1\":{\"88\":1}}],[\"判题机的运行速度一般在每秒\",{\"1\":{\"88\":1}}],[\"判断栈是否为空\",{\"1\":{\"111\":1}}],[\"判断是否为空\",{\"1\":{\"110\":1}}],[\"判断是否可以移动函数\",{\"1\":{\"51\":1}}],[\"判断是重启游戏还是结束游戏\",{\"1\":{\"8\":1,\"20\":1}}],[\"判断游戏是否获胜\",{\"1\":{\"49\":1}}],[\"判断能不能向左移动\",{\"1\":{\"36\":1}}],[\"判断能否向左划\",{\"1\":{\"36\":1,\"40\":1}}],[\"判断能否向这个方向移动\",{\"1\":{\"18\":1}}],[\"判断能否移动\",{\"0\":{\"18\":1}}],[\"判断矩阵每一行有没有可以右移动的元素\",{\"1\":{\"18\":1}}],[\"判断矩阵每一行有没有可以左移动的元素\",{\"1\":{\"18\":1}}],[\"判断一行里面能否有元素进行左移动或合并\",{\"1\":{\"18\":1}}],[\"判断输赢\",{\"0\":{\"17\":1}}],[\"判断棋盘操作是否存在且可行\",{\"1\":{\"16\":1}}],[\"判断邻近元素能否合并\",{\"1\":{\"14\":1}}],[\"输出队头元素\",{\"1\":{\"89\":1}}],[\"输出样例\",{\"0\":{\"88\":1}}],[\"输出包含两个\",{\"1\":{\"86\":1}}],[\"输出格式\",{\"0\":{\"86\":1}}],[\"输入样例\",{\"0\":{\"87\":1}}],[\"输入包含两行\",{\"1\":{\"85\":1}}],[\"输入格式\",{\"0\":{\"85\":1}}],[\"同行数据之间用空格隔开\",{\"1\":{\"85\":1}}],[\"同时排除掉非零的位置\",{\"1\":{\"12\":1}}],[\"代码\",{\"0\":{\"111\":1},\"1\":{\"98\":1,\"99\":1,\"100\":1}}],[\"代码层面也相对于那些算法更好写\",{\"1\":{\"88\":1}}],[\"代码没写出来\",{\"1\":{\"60\":1}}],[\"代表数组的具体数值\",{\"1\":{\"85\":1}}],[\"个整数\",{\"1\":{\"85\":1}}],[\"个数字\",{\"1\":{\"84\":1}}],[\"第三步中的序列已经分别有序且第一个序列中的数都小于第二个数\",{\"1\":{\"102\":1}}],[\"第二行输出\",{\"1\":{\"86\":1}}],[\"第二行有\",{\"1\":{\"85\":1}}],[\"第一步要是要把数列分成两个部分\",{\"1\":{\"102\":1}}],[\"第一步并不是直接分成前后两个序列\",{\"1\":{\"102\":1}}],[\"第一行输出\",{\"1\":{\"86\":1}}],[\"第一行包含两个整数\",{\"1\":{\"85\":1}}],[\"第一天就有点难\",{\"1\":{\"64\":1}}],[\"分别代表数组长度和滑动窗口的长度\",{\"1\":{\"85\":1}}],[\"窗口中的最大值和最小值\",{\"1\":{\"84\":1}}],[\"窗口位置\",{\"1\":{\"84\":1}}],[\"7\",{\"1\":{\"84\":8,\"87\":1,\"88\":1}}],[\"7个名额\",{\"1\":{\"2\":1}}],[\"346354943\",{\"1\":{\"89\":1}}],[\"3被弹出\",{\"1\":{\"89\":1}}],[\"3也不可能成为最大值了\",{\"1\":{\"89\":1}}],[\"3已经不是最大值了\",{\"1\":{\"89\":1}}],[\"3只要进去就是最大值\",{\"1\":{\"89\":1}}],[\"3比1大\",{\"1\":{\"89\":1}}],[\"3有没有可能成为队列中最大的元素\",{\"1\":{\"89\":1}}],[\"3\",{\"1\":{\"84\":28,\"87\":4,\"88\":7,\"89\":9}}],[\"3e0594757ea2535b5aeb9611fde91794c2cd3dd4ea4f3312d\",{\"1\":{\"2\":1}}],[\"该数组为\",{\"1\":{\"84\":1}}],[\"它是一个const指针\",{\"1\":{\"112\":1}}],[\"它是一种运算受限的线性表\",{\"1\":{\"109\":1}}],[\"它是把栈顶元素删除掉\",{\"1\":{\"109\":1}}],[\"它是把新元素放到栈顶元素的上面\",{\"1\":{\"109\":1}}],[\"它从数组的最左边移动到最右边\",{\"1\":{\"84\":1}}],[\"它的主要作用是将棋盘所有位置元素复原为\",{\"1\":{\"13\":1}}],[\"它的\",{\"1\":{\"8\":1}}],[\"滑动窗口\",{\"1\":{\"84\":1}}],[\"例题分析\",{\"0\":{\"84\":1}}],[\"定义解释清楚了之后我们来看看这么个队列有个什么用\",{\"1\":{\"83\":1}}],[\"定义很简单对吧\",{\"1\":{\"83\":1}}],[\"定义\",{\"0\":{\"83\":1},\"1\":{\"112\":1}}],[\"单调队列顾名思义\",{\"1\":{\"83\":1}}],[\"单调队列\",{\"0\":{\"81\":1,\"82\":1},\"1\":{\"83\":1}}],[\"买什么都悠着点\",{\"1\":{\"80\":1}}],[\"买了几个挂钩\",{\"1\":{\"78\":1}}],[\"纯模拟\",{\"1\":{\"79\":1}}],[\"纯纯的数学题\",{\"1\":{\"70\":1}}],[\"几次才能成功一次\",{\"1\":{\"79\":1}}],[\"也没用\",{\"1\":{\"108\":1}}],[\"也没证书\",{\"1\":{\"108\":1}}],[\"也不知道笑点到底在哪个地方\",{\"1\":{\"91\":1}}],[\"也就是3和\",{\"1\":{\"89\":1}}],[\"也就是3\",{\"1\":{\"89\":1}}],[\"也就是上面我推荐那一句名言\",{\"1\":{\"89\":1}}],[\"也就是说\",{\"1\":{\"8\":1}}],[\"也挺好的\",{\"1\":{\"79\":1}}],[\"贴上后触控不灵敏了\",{\"1\":{\"79\":1}}],[\"给定一个大小为\",{\"1\":{\"84\":1}}],[\"给自己的手机买了个钢化膜\",{\"1\":{\"79\":1}}],[\"给新列表后面补零\",{\"1\":{\"14\":1}}],[\"累了个半死\",{\"1\":{\"79\":1}}],[\"😢\",{\"1\":{\"78\":1}}],[\"🚀\",{\"1\":{\"76\":1}}],[\"回忆起了当初我刚来的时候\",{\"1\":{\"77\":1}}],[\"学不会了\",{\"1\":{\"77\":1}}],[\"学习相关的事情也是尽量跟上\",{\"1\":{\"2\":1}}],[\"电路真的好难\",{\"1\":{\"77\":1}}],[\"坐了某lxc的非主流摩托车\",{\"1\":{\"76\":1}}],[\"租空调\",{\"1\":{\"76\":1}}],[\"yyds\",{\"1\":{\"92\":1}}],[\"y2k\",{\"0\":{\"76\":1}}],[\"you\",{\"1\":{\"19\":1,\"41\":1,\"44\":1}}],[\"比如说如果后面的指针\",{\"1\":{\"102\":1}}],[\"比如说我\",{\"1\":{\"75\":1}}],[\"比队列中所有元素\",{\"1\":{\"89\":1}}],[\"比赛之前我又把自己学生证搞丢了\",{\"1\":{\"59\":1}}],[\"建议先看思路\",{\"1\":{\"75\":1}}],[\"犯了很多低级错误\",{\"1\":{\"68\":1}}],[\"真是太粗心了\",{\"1\":{\"68\":1}}],[\"真是九头牛都拉不回来😥\",{\"1\":{\"60\":1}}],[\"唉\",{\"1\":{\"68\":1}}],[\"´ο｀\",{\"1\":{\"68\":1}}],[\"ε=\",{\"1\":{\"68\":1}}],[\"又名堆栈\",{\"1\":{\"109\":1}}],[\"又称分区交换排序\",{\"1\":{\"102\":1}}],[\"又是水题\",{\"1\":{\"68\":1}}],[\"又进步了一点点吧\",{\"1\":{\"0\":1}}],[\"至少比以前身体好点了\",{\"1\":{\"67\":1}}],[\"麻了\",{\"1\":{\"67\":1}}],[\"耽误了很多时间\",{\"1\":{\"67\":1}}],[\"本来是一道简单的题\",{\"1\":{\"67\":1}}],[\"本来我们就是打星参赛\",{\"1\":{\"59\":1}}],[\"根据往年的情况到时候大概率碰到很多dp题和数据结构\",{\"1\":{\"66\":1}}],[\"根据状态画出游戏的界面\",{\"1\":{\"20\":2}}],[\"仰望hpy大佬\",{\"1\":{\"65\":1}}],[\"今天斥巨资47元买了个好一点的枕头\",{\"1\":{\"80\":1}}],[\"今天第一次跑了六公里\",{\"1\":{\"79\":1}}],[\"今天没什么新鲜事儿\",{\"1\":{\"78\":1}}],[\"今天做核酸\",{\"1\":{\"76\":1}}],[\"今天做一道简单的dp题\",{\"1\":{\"66\":1}}],[\"今天练得题还是比较简单\",{\"1\":{\"73\":1}}],[\"今天被突然到来的一场icpc网络赛打蒙了\",{\"1\":{\"73\":1}}],[\"今天来开开心心的做第二道题喽\",{\"1\":{\"71\":1}}],[\"今天跑了好几公里\",{\"1\":{\"67\":1}}],[\"今天这一题做个简单的floyd算法安慰一下我的心灵\",{\"1\":{\"65\":1}}],[\"今天打icpc真难\",{\"1\":{\"65\":1}}],[\"今天去和lxc他们玩了一晚上桌游\",{\"1\":{\"64\":1}}],[\"贝尔曼福特算法已经忘光光了\",{\"1\":{\"64\":1}}],[\"开始做图论的题的第二天\",{\"1\":{\"65\":1}}],[\"开始做图论的题了\",{\"1\":{\"64\":1}}],[\"开打的时候就很难受\",{\"1\":{\"59\":1}}],[\"题目来源\",{\"1\":{\"84\":1}}],[\"题目记录\",{\"2\":{\"61\":1,\"63\":1,\"72\":1,\"74\":1}}],[\"题单\",{\"2\":{\"63\":1,\"72\":1,\"74\":1}}],[\"很简单对吧\",{\"1\":{\"88\":1}}],[\"很简单的题\",{\"1\":{\"78\":1}}],[\"很简陋不要吐槽\",{\"1\":{\"83\":1}}],[\"很开心捏😘\",{\"1\":{\"64\":1}}],[\"很容易写出bug\",{\"1\":{\"62\":1}}],[\"很可惜啊😭\",{\"1\":{\"60\":1}}],[\"做某个题单的第一道题\",{\"1\":{\"62\":1}}],[\"刷题日记day9\",{\"0\":{\"80\":1}}],[\"刷题日记day8\",{\"0\":{\"79\":1}}],[\"刷题日记day7\",{\"0\":{\"78\":1}}],[\"刷题日记day6\",{\"0\":{\"77\":1}}],[\"刷题日记day5\",{\"0\":{\"76\":1}}],[\"刷题日记day4\",{\"0\":{\"75\":1}}],[\"刷题日记day3\",{\"0\":{\"73\":1}}],[\"刷题日记day2\",{\"0\":{\"71\":1}}],[\"刷题日记day16\",{\"0\":{\"70\":1}}],[\"刷题日记day15\",{\"0\":{\"69\":1}}],[\"刷题日记day14\",{\"0\":{\"68\":1}}],[\"刷题日记day13\",{\"0\":{\"67\":1}}],[\"刷题日记day12\",{\"0\":{\"66\":1}}],[\"刷题日记day11\",{\"0\":{\"65\":1}}],[\"刷题日记day10\",{\"0\":{\"64\":1}}],[\"刷题日记day1\",{\"0\":{\"62\":1}}],[\"刷新画面\",{\"1\":{\"47\":1}}],[\"竞赛\",{\"2\":{\"61\":1}}],[\"希望以后写题之前得认真看懂题\",{\"1\":{\"60\":1}}],[\"感觉比我自己半个月学的都多\",{\"1\":{\"108\":1}}],[\"感觉摩托是真的爽\",{\"1\":{\"76\":1}}],[\"感觉还行\",{\"1\":{\"67\":1}}],[\"感觉这道题只是工作量大了点\",{\"1\":{\"60\":1}}],[\"感觉队友们都很默契啊\",{\"1\":{\"0\":1}}],[\"你的任务是确定滑动窗口位于每个位置时\",{\"1\":{\"84\":1}}],[\"你只能在窗口中看到\",{\"1\":{\"84\":1}}],[\"你就可以退役了\",{\"1\":{\"83\":1}}],[\"你们队就从此少了一个人\",{\"1\":{\"60\":1}}],[\"你会发现\",{\"1\":{\"8\":1}}],[\"生日蛋糕那一题也就是b题应该是可以写出来的\",{\"1\":{\"60\":1}}],[\"生成的特殊字典里\",{\"1\":{\"8\":1}}],[\"过也是可以的\",{\"1\":{\"88\":1}}],[\"过了三题\",{\"1\":{\"65\":1}}],[\"过不了\",{\"1\":{\"60\":1}}],[\"过关分数\",{\"1\":{\"10\":1}}],[\"调了一阵\",{\"1\":{\"60\":1}}],[\"筷子这一题真的是集全队之力\",{\"1\":{\"60\":1}}],[\"认为它是个dp题\",{\"1\":{\"60\":1}}],[\"裁纸游戏耽误了很多时间\",{\"1\":{\"60\":1}}],[\"之后\",{\"1\":{\"102\":1}}],[\"之后一直卡壳\",{\"1\":{\"60\":1}}],[\"之后草草放上去了几道巨难的题\",{\"1\":{\"59\":1}}],[\"zhihu\",{\"1\":{\"89\":1}}],[\"zhuanlan\",{\"1\":{\"89\":1}}],[\"zzh想写大模拟\",{\"1\":{\"60\":1}}],[\"zzh还是非常给力的\",{\"1\":{\"60\":1}}],[\"zip\",{\"1\":{\"7\":1,\"15\":2,\"23\":1,\"27\":1,\"40\":1}}],[\"自己学习造一些轮子还是有很多帮助的\",{\"1\":{\"91\":1}}],[\"自己的计划几乎被打乱了\",{\"1\":{\"2\":1}}],[\"自我感觉上感觉发挥的是比较差的\",{\"1\":{\"60\":1}}],[\"赛时a了4题\",{\"1\":{\"60\":1}}],[\"赛前热身赛直接爆零\",{\"1\":{\"59\":1}}],[\"赛前封校封教学楼导致连个比赛场地都申请不下来\",{\"1\":{\"59\":1}}],[\"反思\",{\"0\":{\"60\":1}}],[\"后来明白以后才发现这个算法也挺简单的\",{\"1\":{\"81\":1}}],[\"后来通过了习题集却没有题\",{\"1\":{\"59\":1}}],[\"后的元素在\",{\"1\":{\"14\":1}}],[\"主要是每个人好像都会但是每个人思路又不太一样\",{\"1\":{\"60\":1}}],[\"主办方在到时间之后十五分钟都没有把我们的登录申请通过\",{\"1\":{\"59\":1}}],[\"主逻辑\",{\"0\":{\"6\":1}}],[\"前还是后\",{\"1\":{\"102\":1}}],[\"前言\",{\"0\":{\"59\":1}}],[\"前面顺顺利利\",{\"1\":{\"21\":1}}],[\"河北省赛赛后反思\",{\"0\":{\"58\":1}}],[\"河南省赛\",{\"1\":{\"2\":1}}],[\"控制游戏的重启和结束以及操作\",{\"1\":{\"53\":1}}],[\"获取栈中元素个数\",{\"1\":{\"110\":1}}],[\"获取栈顶元素\",{\"1\":{\"110\":1}}],[\"获取action判断能否移动\",{\"1\":{\"48\":1}}],[\"获胜则结束游戏\",{\"1\":{\"49\":1}}],[\"获得有效键值列表\",{\"1\":{\"7\":1}}],[\"操作函数\",{\"1\":{\"48\":1}}],[\"操作是否存在\",{\"1\":{\"16\":1}}],[\"全部重新开始\",{\"1\":{\"46\":1}}],[\"画格子的横线和文字数字\",{\"1\":{\"44\":1}}],[\"画格子的竖线\",{\"1\":{\"43\":1}}],[\"画出当前棋盘状态\",{\"1\":{\"8\":1}}],[\"提示文字\",{\"1\":{\"41\":1}}],[\"提供了一个字典的子类\",{\"1\":{\"5\":1}}],[\"包括游戏运行的流程控制状态机\",{\"1\":{\"45\":1}}],[\"包括棋盘和方块数值\",{\"1\":{\"41\":1}}],[\"包括上下左右移动和重新开始\",{\"1\":{\"24\":1}}],[\"向一个栈插入新元素又称作进栈\",{\"1\":{\"109\":1}}],[\"向后移一位\",{\"1\":{\"102\":1}}],[\"向下划\",{\"1\":{\"35\":1,\"40\":1}}],[\"向上划\",{\"1\":{\"34\":1,\"40\":1}}],[\"向右划\",{\"1\":{\"33\":1,\"40\":1}}],[\"向左划\",{\"1\":{\"32\":1,\"40\":2}}],[\"计算方块的数值\",{\"1\":{\"29\":1}}],[\"每个位置滑动窗口中的最大值\",{\"1\":{\"86\":1}}],[\"每个位置滑动窗口中的最小值\",{\"1\":{\"86\":1}}],[\"每次从里面拿东西也只能从最上面拿\",{\"1\":{\"109\":1}}],[\"每次往里放东西都会摞在最上面\",{\"1\":{\"109\":1}}],[\"每次将未排序中的一个元素插入到已排序的元素中正确的位置\",{\"1\":{\"100\":1}}],[\"每次检查相邻两个元素\",{\"1\":{\"99\":1}}],[\"每次遍历数组找出第i小的数然后与第i位交换位置\",{\"1\":{\"98\":1}}],[\"每次方框向前移动一格\",{\"1\":{\"88\":1}}],[\"每次滑动窗口向右移动一个位置\",{\"1\":{\"84\":1}}],[\"每次操作加入随机两个方块\",{\"1\":{\"26\":1,\"40\":1}}],[\"每天固定的捅一次喉咙+捅两次鼻子\",{\"1\":{\"2\":1}}],[\"添加随机方块\",{\"1\":{\"26\":1}}],[\"重新开始和清零\",{\"1\":{\"25\":1,\"40\":1}}],[\"重置游戏\",{\"1\":{\"46\":1}}],[\"重置游戏棋盘\",{\"1\":{\"20\":1}}],[\"重置棋盘\",{\"0\":{\"13\":1}}],[\"重置\",{\"1\":{\"7\":1}}],[\"变成空棋盘后加入两个随机方块\",{\"1\":{\"25\":1}}],[\"体现面向对象的编程方法\",{\"1\":{\"23\":1}}],[\"面向对象重构\",{\"0\":{\"22\":1}}],[\"某些操作会导致程序报错\",{\"1\":{\"21\":1}}],[\"其实\",{\"1\":{\"102\":1}}],[\"其实也有可能是我们算法的时间复杂度有点高\",{\"1\":{\"60\":1}}],[\"其实也还好那时候排名还在前五十\",{\"1\":{\"60\":1}}],[\"其实签到题是d题\",{\"1\":{\"60\":1}}],[\"其实并没有完美运行\",{\"1\":{\"21\":1}}],[\"其实这些还不是最重要的\",{\"1\":{\"2\":1}}],[\"查了一下百度\",{\"1\":{\"21\":1}}],[\"好了\",{\"1\":{\"83\":1}}],[\"好难受\",{\"1\":{\"79\":1}}],[\"好无聊啊\",{\"1\":{\"78\":1}}],[\"好像是因为curses库只支持linux\",{\"1\":{\"21\":1}}],[\"好像前面也不太可能出问题\",{\"1\":{\"21\":1}}],[\"好想回到没有疫情的时候啊\",{\"1\":{\"2\":1}}],[\"偏偏到运行这一步出了问题\",{\"1\":{\"21\":1}}],[\"运行游戏的主逻辑类\",{\"1\":{\"45\":1}}],[\"运行\",{\"0\":{\"21\":1}}],[\"作为最大值了\",{\"1\":{\"89\":1}}],[\"作为\",{\"1\":{\"20\":1}}],[\"作用是生成一个特殊的字典\",{\"1\":{\"8\":1}}],[\"最坏情况\",{\"1\":{\"99\":1,\"100\":1}}],[\"最好情况\",{\"1\":{\"99\":1,\"100\":1}}],[\"最大值\",{\"1\":{\"84\":1}}],[\"最大上升子序列模板题\",{\"1\":{\"69\":1}}],[\"最小值\",{\"1\":{\"84\":1}}],[\"最近感觉自己觉醒了勤俭持家的本能\",{\"1\":{\"80\":1}}],[\"最后去网上找了体解才搞懂\",{\"1\":{\"70\":1}}],[\"最后看出来规律的了\",{\"1\":{\"60\":1}}],[\"最后zzh上手写\",{\"1\":{\"60\":1}}],[\"最后好不容易才把宿舍的自习室申请下来的当场地了\",{\"1\":{\"59\":1}}],[\"最后成功运行了\",{\"1\":{\"21\":1}}],[\"最后\",{\"1\":{\"20\":1}}],[\"最高分\",{\"1\":{\"10\":1}}],[\"接下来是5\",{\"1\":{\"89\":1}}],[\"接下来是\",{\"1\":{\"89\":2}}],[\"接着\",{\"1\":{\"20\":1}}],[\"接收一个可迭代对象作为参数\",{\"1\":{\"17\":1}}],[\"bubble\",{\"1\":{\"99\":2}}],[\"bug也好找\",{\"1\":{\"91\":1}}],[\"bug\",{\"0\":{\"76\":1}}],[\"buffering\",{\"1\":{\"20\":1}}],[\"brothers\",{\"0\":{\"71\":1}}],[\"balance\",{\"0\":{\"66\":1}}],[\"best\",{\"1\":{\"44\":1}}],[\"boolean\",{\"1\":{\"111\":1}}],[\"bool\",{\"1\":{\"17\":3,\"99\":1}}],[\"禁止终端程序的行缓冲\",{\"1\":{\"20\":1}}],[\"模式\",{\"1\":{\"20\":1}}],[\"模块用来生成随机数\",{\"1\":{\"5\":1}}],[\"首先定义一个arraystack\",{\"1\":{\"110\":1}}],[\"首先我们使用一个数组来模拟一个双向队列\",{\"1\":{\"89\":1}}],[\"首先开局看错签到题耽误了时间\",{\"1\":{\"60\":1}}],[\"首先\",{\"1\":{\"20\":1}}],[\"理解\",{\"1\":{\"20\":1}}],[\"实现的action类可以对于每个窗体实现操作\",{\"1\":{\"23\":1}}],[\"实现过程\",{\"0\":{\"5\":1}}],[\"实例化游戏界面对象并设置游戏获胜条件为\",{\"1\":{\"20\":1}}],[\"使其相邻的元素成为新的栈顶元素\",{\"1\":{\"109\":1}}],[\"使之成为新的栈顶元素\",{\"1\":{\"109\":1}}],[\"使用线段树\",{\"1\":{\"88\":1}}],[\"使用颜色配置默认值\",{\"1\":{\"20\":1}}],[\"使这个队列保持单调性\",{\"1\":{\"83\":1}}],[\"使游戏变成初始状态\",{\"1\":{\"8\":1}}],[\"将数列划分为两部分\",{\"1\":{\"102\":1}}],[\"将数组中的元素分为已排序和未排序两部分\",{\"1\":{\"100\":1}}],[\"将所有数值全部回归初始状态\",{\"1\":{\"46\":1}}],[\"将相邻的两个数值相同的方格合并\",{\"1\":{\"31\":1,\"40\":1}}],[\"将相邻的两个数值相同的格子合并\",{\"1\":{\"31\":1}}],[\"将矩阵向左收缩\",{\"1\":{\"30\":1,\"40\":1}}],[\"将矩阵向左划\",{\"1\":{\"29\":1}}],[\"将整个棋盘重置\",{\"1\":{\"25\":1}}],[\"将一直保持现有状态\",{\"1\":{\"20\":1}}],[\"将输入与行为进行关联\",{\"1\":{\"7\":1}}],[\"完成以上工作后\",{\"1\":{\"20\":1}}],[\"完成主逻辑\",{\"0\":{\"20\":1}}],[\"完成能否向其他方向移动的判断\",{\"1\":{\"18\":1}}],[\"达到刷新的目的\",{\"1\":{\"19\":1}}],[\"清空屏幕\",{\"1\":{\"19\":1}}],[\"|\",{\"1\":{\"19\":3,\"43\":3,\"44\":3}}],[\"绘制提示文字\",{\"1\":{\"19\":1}}],[\"绘制行列边框分割线\",{\"1\":{\"19\":1}}],[\"绘制分数和最高分\",{\"1\":{\"19\":1}}],[\"绘制竖直分割线的函数\",{\"1\":{\"19\":1}}],[\"绘制水平分割线的函数\",{\"1\":{\"19\":1}}],[\"绘制函数\",{\"1\":{\"19\":1}}],[\"绘制游戏界面\",{\"0\":{\"19\":1}}],[\"合并也可以看作是在移动\",{\"1\":{\"18\":1}}],[\"合并后\",{\"1\":{\"14\":1}}],[\"检查能否移动\",{\"1\":{\"18\":1}}],[\"传入矩阵\",{\"1\":{\"18\":1}}],[\"传入要移动的方向\",{\"1\":{\"18\":1}}],[\"传入的是矩阵每一行元素在内层\",{\"1\":{\"17\":1}}],[\"传入了每一行的元素并依次比较这一行的每个元素与\",{\"1\":{\"17\":1}}],[\"外层的\",{\"1\":{\"17\":2}}],[\"里面需要一个数组datas来存储所有数据\",{\"1\":{\"110\":1}}],[\"里面嵌套了另一个\",{\"1\":{\"17\":1}}],[\"里处理后返回的\",{\"1\":{\"17\":1}}],[\"里层的\",{\"1\":{\"17\":1}}],[\"无法移动和合并时\",{\"1\":{\"17\":1}}],[\"任意一个位置的数大于设定的\",{\"1\":{\"17\":1}}],[\"四个\",{\"1\":{\"16\":1}}],[\"把栈的空间扩至原先的两倍大\",{\"1\":{\"111\":1}}],[\"把另一端称为栈底\",{\"1\":{\"109\":1}}],[\"把不同的棋盘操作作为不同的\",{\"1\":{\"16\":1}}],[\"把零散的非零单元挤到一块\",{\"1\":{\"14\":1}}],[\"字典中\",{\"1\":{\"16\":1}}],[\"字典中有\",{\"1\":{\"16\":1}}],[\"字典\",{\"1\":{\"16\":1}}],[\"创建\",{\"1\":{\"16\":1}}],[\"创建棋盘\",{\"0\":{\"10\":1}}],[\"函数需要传一个函数作为参数\",{\"1\":{\"20\":1}}],[\"函数会激活并初始化终端进入\",{\"1\":{\"20\":1}}],[\"函数传入的\",{\"1\":{\"19\":1}}],[\"函数中传入了一个\",{\"1\":{\"20\":1}}],[\"函数中\",{\"1\":{\"18\":1}}],[\"函数用来判断游戏是否结束\",{\"1\":{\"17\":1}}],[\"函数\",{\"1\":{\"17\":1,\"19\":1}}],[\"函数方法中\",{\"1\":{\"17\":1}}],[\"函数里的部分代码\",{\"1\":{\"16\":1}}],[\"函数以一个字符作为参数\",{\"1\":{\"7\":1}}],[\"矩阵向左收紧\",{\"1\":{\"30\":1}}],[\"矩阵翻转\",{\"1\":{\"28\":1,\"40\":1}}],[\"矩阵逆转\",{\"1\":{\"15\":1}}],[\"矩阵转置\",{\"1\":{\"15\":2,\"27\":1,\"40\":1}}],[\"矩阵转置与矩阵逆转\",{\"0\":{\"15\":1}}],[\"内置的\",{\"1\":{\"15\":1,\"17\":1}}],[\"内定义的\",{\"1\":{\"14\":1}}],[\"×\",{\"1\":{\"15\":1}}],[\"减少重复劳动\",{\"1\":{\"15\":1}}],[\"加入这两个操作可以大大节省我们的代码量\",{\"1\":{\"15\":1}}],[\"加入乘\",{\"1\":{\"14\":1}}],[\"先把找最大值的代码放出来\",{\"1\":{\"89\":1}}],[\"先前学习这个算法的时候一直搞不明白\",{\"1\":{\"81\":1}}],[\"先向左收缩然后合并然后再向左收缩完成一次操作\",{\"1\":{\"31\":1,\"40\":1}}],[\"先挤到一块再合并再挤到一块\",{\"1\":{\"14\":1}}],[\"先将非零的元素全拿出来加入到新列表\",{\"1\":{\"14\":1}}],[\"否则返回\",{\"1\":{\"17\":1}}],[\"否则报错\",{\"1\":{\"14\":1}}],[\"否则等于\",{\"1\":{\"12\":1}}],[\"断言合并后不会改变行列大小\",{\"1\":{\"14\":1}}],[\"新列表中加入该元素\",{\"1\":{\"14\":1}}],[\"新列表加入元素\",{\"1\":{\"14\":1}}],[\"<<\",{\"1\":{\"89\":6}}],[\"<=\",{\"1\":{\"98\":1,\"100\":1}}],[\"<=i\",{\"1\":{\"89\":3}}],[\"<=a\",{\"1\":{\"89\":2}}],[\"<\",{\"1\":{\"14\":1,\"31\":1,\"40\":1,\"89\":1,\"98\":2,\"99\":1}}],[\"++i\",{\"1\":{\"100\":1}}],[\"++tail\",{\"1\":{\"89\":3}}],[\"+\",{\"1\":{\"14\":2,\"18\":2,\"19\":9,\"31\":2,\"36\":2,\"40\":4,\"42\":1,\"43\":1,\"44\":16,\"48\":1,\"51\":1,\"57\":1,\"98\":1,\"99\":2,\"100\":2}}],[\"+=\",{\"1\":{\"14\":2,\"30\":1,\"31\":1,\"40\":2}}],[\"元素后面\",{\"1\":{\"14\":1}}],[\"t\",{\"1\":{\"111\":5}}],[\"this省略也没有影响\",{\"1\":{\"112\":1}}],[\"this是为了方便访问对象的成员变量而设置的\",{\"1\":{\"112\":1}}],[\"this\",{\"1\":{\"111\":20,\"112\":1}}],[\"the\",{\"0\":{\"68\":1,\"71\":1},\"1\":{\"91\":1}}],[\"top\",{\"1\":{\"110\":1,\"111\":1}}],[\"to\",{\"1\":{\"91\":1}}],[\"tail=0\",{\"1\":{\"89\":4}}],[\"tail\",{\"1\":{\"89\":12}}],[\"tautology\",{\"0\":{\"77\":1}}],[\"training\",{\"0\":{\"117\":1,\"118\":1}}],[\"transpose\",{\"0\":{\"27\":1},\"1\":{\"15\":1,\"16\":4,\"18\":2,\"27\":1,\"34\":2,\"35\":2,\"39\":2,\"40\":11}}],[\"trying\",{\"1\":{\"91\":1}}],[\"true\",{\"1\":{\"14\":1,\"16\":1,\"17\":3,\"18\":2,\"31\":1,\"36\":2,\"40\":3,\"48\":1,\"99\":2,\"111\":1}}],[\"tighten\",{\"0\":{\"30\":1},\"1\":{\"14\":3,\"30\":1,\"31\":2,\"40\":3}}],[\"tuple\",{\"1\":{\"12\":1}}],[\"拆出来是为了方便阅读\",{\"1\":{\"14\":1}}],[\"min\",{\"1\":{\"98\":4}}],[\"minn\",{\"1\":{\"89\":2}}],[\"motion\",{\"0\":{\"80\":1}}],[\"movable\",{\"1\":{\"18\":2}}],[\"moves\",{\"1\":{\"16\":12}}],[\"move\",{\"0\":{\"29\":1,\"32\":1,\"33\":1,\"34\":1,\"35\":1,\"36\":1,\"37\":1,\"38\":1,\"39\":1,\"40\":1,\"48\":1,\"51\":1},\"1\":{\"14\":2,\"16\":6,\"17\":3,\"18\":2,\"20\":2,\"32\":2,\"33\":2,\"34\":2,\"35\":2,\"36\":1,\"37\":2,\"38\":2,\"39\":2,\"40\":20,\"48\":3,\"50\":3,\"51\":2,\"53\":1}}],[\"machine\",{\"0\":{\"67\":1}}],[\"maxn\",{\"1\":{\"89\":4}}],[\"max\",{\"1\":{\"49\":1}}],[\"main\",{\"1\":{\"20\":5,\"89\":1}}],[\"merge\",{\"0\":{\"31\":1},\"1\":{\"14\":2,\"31\":2,\"40\":2}}],[\"mmexport1665747871951\",{\"1\":{\"2\":1}}],[\"注\",{\"1\":{\"14\":1,\"16\":1,\"19\":1}}],[\"然后arraysize\",{\"1\":{\"110\":1}}],[\"然后保证前一个子数列中的数都小于后一个子数列中的数\",{\"1\":{\"102\":1}}],[\"然后轮到3\",{\"1\":{\"89\":1}}],[\"然后发现\",{\"1\":{\"60\":1}}],[\"然后又发现好像也不难\",{\"1\":{\"60\":1}}],[\"然后又发现很多队都写出来了\",{\"1\":{\"60\":1}}],[\"然后又看到h也是一个签到题\",{\"1\":{\"60\":1}}],[\"然后我突然来了点灵感才把它a了😓\",{\"1\":{\"60\":1}}],[\"然后去下载了一个支持win的第三方版本\",{\"1\":{\"21\":1}}],[\"然后同样利用矩阵的转置和逆转来转换矩阵\",{\"1\":{\"18\":1}}],[\"然后再在随机位置生成游戏初始的数值\",{\"1\":{\"13\":1}}],[\"然后判断游戏是否结束\",{\"1\":{\"8\":1}}],[\"更新分数\",{\"1\":{\"13\":1,\"14\":1}}],[\"因为都是我不擅长的领域\",{\"1\":{\"108\":1}}],[\"因为此时数列已经完全有序\",{\"1\":{\"102\":1}}],[\"因为我们使用单调队列算法的时间复杂度只有\",{\"1\":{\"88\":1}}],[\"因为我其实很喜欢安静的地方\",{\"1\":{\"2\":1}}],[\"因为临近ccpc省赛\",{\"1\":{\"66\":1}}],[\"因此为了保持队列的单调性\",{\"1\":{\"89\":1}}],[\"因此\",{\"1\":{\"12\":1}}],[\"才能确定棋盘上的位置\",{\"1\":{\"12\":1}}],[\"等到3出队后它成为最大值的可能\",{\"1\":{\"89\":1}}],[\"等\",{\"1\":{\"12\":1}}],[\"等于\",{\"1\":{\"12\":1}}],[\"方法中\",{\"1\":{\"20\":1}}],[\"方法中传入一个列表\",{\"1\":{\"12\":1}}],[\"方法的调用需要窗体对象\",{\"1\":{\"20\":1}}],[\"方法将传入的内容展示到终端\",{\"1\":{\"19\":1}}],[\"方法判断这个操作是否能在棋盘执行\",{\"1\":{\"16\":1}}],[\"方法来进行矩阵转置\",{\"1\":{\"15\":1}}],[\"方法在棋盘初始化的时候被调用\",{\"1\":{\"13\":1}}],[\"方法会从一个非空的序列\",{\"1\":{\"12\":1}}],[\"方法\",{\"1\":{\"12\":1}}],[\"库的用法\",{\"1\":{\"19\":1,\"20\":1}}],[\"库的\",{\"1\":{\"12\":1}}],[\"于是\",{\"1\":{\"12\":1}}],[\"或4\",{\"1\":{\"26\":1,\"40\":1}}],[\"或\",{\"1\":{\"12\":1}}],[\"或者\",{\"0\":{\"12\":1}}],[\"或者更准确的说是有限状态机\",{\"1\":{\"8\":1}}],[\"或者根本不值一提\",{\"1\":{\"2\":1}}],[\"按照原列表的大小\",{\"1\":{\"14\":1}}],[\"按照游戏规则\",{\"1\":{\"12\":1}}],[\"按照老师们说的\",{\"1\":{\"2\":1}}],[\"java\",{\"1\":{\"110\":1,\"111\":1}}],[\"java实现\",{\"0\":{\"110\":1}}],[\"java实现模拟栈\",{\"0\":{\"108\":1}}],[\"j++\",{\"1\":{\"98\":1}}],[\"join\",{\"1\":{\"19\":1,\"43\":1,\"44\":1}}],[\"j\",{\"1\":{\"12\":7,\"13\":1,\"25\":1,\"26\":5,\"40\":6,\"89\":2,\"98\":4,\"100\":7}}],[\"jpg\",{\"1\":{\"2\":7}}],[\"得到一个随机空白位置的元组坐标\",{\"1\":{\"12\":1}}],[\">>\",{\"1\":{\"89\":3}}],[\">=a\",{\"1\":{\"89\":1}}],[\">=\",{\"1\":{\"17\":1,\"26\":1,\"40\":1,\"49\":1}}],[\">\",{\"1\":{\"12\":1,\"13\":1,\"19\":1,\"43\":1,\"44\":1,\"99\":1,\"100\":2}}],[\"endl\",{\"1\":{\"89\":2}}],[\"explore\",{\"0\":{\"122\":1}}],[\"exchange\",{\"0\":{\"64\":1},\"1\":{\"102\":1}}],[\"exit\",{\"0\":{\"54\":1},\"1\":{\"7\":3,\"8\":15,\"19\":1,\"20\":6,\"23\":3,\"41\":1,\"44\":1,\"53\":2,\"54\":2,\"55\":1,\"56\":1,\"57\":1}}],[\"empty\",{\"1\":{\"26\":2,\"40\":2}}],[\"else\",{\"1\":{\"12\":1,\"14\":2,\"16\":1,\"18\":1,\"19\":3,\"26\":1,\"31\":2,\"40\":3,\"43\":1,\"44\":5,\"48\":1,\"54\":1,\"111\":1}}],[\"element\",{\"1\":{\"12\":3}}],[\"从一个栈删除元素又称作出栈或退栈\",{\"1\":{\"109\":1}}],[\"从队尾出队\",{\"1\":{\"89\":1}}],[\"从中选出最小的和最大的值\",{\"1\":{\"88\":1}}],[\"从左至右\",{\"1\":{\"86\":2}}],[\"从\",{\"1\":{\"12\":1}}],[\"404\",{\"1\":{\"113\":1}}],[\"4\",{\"0\":{\"12\":1},\"1\":{\"12\":3,\"15\":2,\"26\":1,\"40\":1,\"89\":1}}],[\"4x4\",{\"1\":{\"10\":1}}],[\"随机生成一个\",{\"0\":{\"12\":1}}],[\"随机数模块\",{\"1\":{\"4\":1}}],[\"棋盘走一步\",{\"0\":{\"16\":1}}],[\"棋盘操作\",{\"0\":{\"11\":1}}],[\"棋盘重置\",{\"1\":{\"10\":1}}],[\"棋盘会进行相应移动一次\",{\"1\":{\"8\":1}}],[\"https\",{\"1\":{\"89\":1}}],[\"h>\",{\"1\":{\"89\":1}}],[\"hor\",{\"1\":{\"19\":3}}],[\"highscore\",{\"1\":{\"10\":1,\"13\":2,\"19\":3}}],[\"head++\",{\"1\":{\"89\":3}}],[\"head<=tail\",{\"1\":{\"89\":3}}],[\"head=1\",{\"1\":{\"89\":4}}],[\"head\",{\"1\":{\"89\":9}}],[\"help\",{\"1\":{\"19\":4,\"41\":2,\"44\":6}}],[\"height\",{\"1\":{\"10\":2,\"12\":1,\"13\":1}}],[\"height=4\",{\"1\":{\"10\":1}}],[\"hexo博客终于弄好啦\",{\"1\":{\"0\":1}}],[\"0\",{\"1\":{\"10\":2,\"12\":1,\"13\":3,\"14\":5,\"18\":4,\"19\":2,\"25\":1,\"26\":1,\"30\":2,\"31\":1,\"36\":3,\"40\":8,\"43\":1,\"44\":2,\"46\":1,\"89\":1,\"100\":1,\"111\":4}}],[\"宽\",{\"1\":{\"10\":1}}],[\"高\",{\"1\":{\"10\":1}}],[\"of\",{\"0\":{\"75\":1}}],[\"or\",{\"0\":{\"54\":1},\"1\":{\"54\":1,\"55\":1,\"56\":1}}],[\"ord\",{\"1\":{\"7\":2,\"23\":1}}],[\"over=self\",{\"1\":{\"47\":1}}],[\"over=false\",{\"1\":{\"44\":1}}],[\"over\",{\"0\":{\"50\":1,\"56\":1},\"1\":{\"19\":1,\"41\":2,\"44\":8,\"46\":1,\"47\":1,\"50\":3,\"53\":2,\"56\":1}}],[\"object\",{\"1\":{\"10\":1,\"20\":1,\"23\":1,\"40\":1,\"44\":1,\"110\":1,\"111\":2}}],[\"～\",{\"1\":{\"10\":1}}],[\"码值\",{\"1\":{\"9\":1}}],[\"返回栈中元素个数\",{\"1\":{\"111\":1}}],[\"返回栈顶元素\",{\"1\":{\"111\":1}}],[\"返回null\",{\"1\":{\"111\":1}}],[\"返回一个布尔值\",{\"1\":{\"51\":1}}],[\"返回\",{\"1\":{\"17\":1,\"31\":1}}],[\"返回输入键位对应的行为\",{\"1\":{\"9\":1}}],[\"返回按下键位的\",{\"1\":{\"9\":1}}],[\"返回参数对应的\",{\"1\":{\"7\":1}}],[\"null\",{\"1\":{\"111\":2}}],[\"num\",{\"1\":{\"19\":3,\"43\":3,\"44\":3,\"49\":1,\"98\":4}}],[\"n^2\",{\"1\":{\"98\":1,\"99\":2,\"100\":2}}],[\"namespace\",{\"1\":{\"89\":1}}],[\"none\",{\"1\":{\"40\":1}}],[\"notes\",{\"0\":{\"120\":1}}],[\"not\",{\"1\":{\"8\":4,\"9\":1,\"17\":1,\"20\":3,\"23\":1,\"50\":1,\"113\":1}}],[\"new\",{\"1\":{\"12\":3,\"14\":10,\"30\":4,\"31\":6,\"40\":10,\"111\":1}}],[\"n\",{\"1\":{\"9\":1,\"19\":1,\"23\":1,\"42\":1,\"44\":1,\"60\":1,\"85\":2,\"89\":4,\"98\":3,\"99\":3,\"100\":4}}],[\"util\",{\"1\":{\"110\":1,\"111\":1}}],[\"using\",{\"1\":{\"89\":1}}],[\"use\",{\"1\":{\"20\":1,\"57\":1}}],[\"user\",{\"1\":{\"9\":1,\"20\":2}}],[\"up\",{\"0\":{\"34\":1,\"39\":1},\"1\":{\"7\":3,\"8\":2,\"16\":2,\"18\":1,\"19\":1,\"23\":3,\"34\":1,\"39\":1,\"40\":2,\"41\":1,\"44\":1}}],[\"grid=self\",{\"1\":{\"47\":1}}],[\"grid=none\",{\"1\":{\"44\":1}}],[\"grid\",{\"1\":{\"40\":1,\"44\":8,\"46\":3,\"47\":1,\"48\":2,\"49\":1,\"51\":1}}],[\"grid类包含所有对于格子计算的操作\",{\"1\":{\"24\":1}}],[\"grid类\",{\"0\":{\"24\":1}}],[\"getattr\",{\"1\":{\"48\":1,\"51\":1,\"57\":1}}],[\"getch\",{\"1\":{\"9\":1,\"23\":1}}],[\"get\",{\"1\":{\"9\":1,\"20\":2,\"23\":1,\"53\":1,\"54\":1}}],[\"gamemanager类\",{\"0\":{\"45\":1}}],[\"gamefield\",{\"1\":{\"10\":1,\"20\":1}}],[\"game函数表示的是游戏进行时的状态\",{\"1\":{\"8\":1}}],[\"game函数表示的是游戏结束时的状态\",{\"1\":{\"8\":1}}],[\"gameover\",{\"1\":{\"8\":4,\"17\":2,\"19\":3,\"20\":4}}],[\"game\",{\"0\":{\"53\":1,\"62\":1},\"1\":{\"8\":11,\"19\":1,\"20\":16,\"41\":1,\"44\":1,\"52\":1,\"53\":2}}],[\"直到两个指针相遇\",{\"1\":{\"102\":1}}],[\"直到数列有序\",{\"1\":{\"99\":1}}],[\"直到zzh写完试样例的时候才发觉这道题不是简单的大模拟\",{\"1\":{\"60\":1}}],[\"直到还剩两个小时的时候还很乐观\",{\"1\":{\"60\":1}}],[\"直到后来认真分析了数据范围和大小\",{\"1\":{\"60\":1}}],[\"直到获得用户有效输入才返回对应行为\",{\"1\":{\"9\":1}}],[\"直到达到\",{\"1\":{\"8\":1}}],[\"阻塞＋循环\",{\"1\":{\"9\":1}}],[\"行为时\",{\"1\":{\"8\":1}}],[\"当前的数的位置全放对后\",{\"1\":{\"102\":1}}],[\"当前分数\",{\"1\":{\"10\":1}}],[\"当有两个相等键值的纪录r和s\",{\"1\":{\"94\":1}}],[\"当然如果你是大佬\",{\"1\":{\"88\":1}}],[\"当一个队友开始决定去写大模拟的时候\",{\"1\":{\"60\":1}}],[\"当左边有一个数和右边的数相等时\",{\"1\":{\"18\":1}}],[\"当左边有空位\",{\"1\":{\"18\":1}}],[\"当上下左右四个方向都不能移动时\",{\"1\":{\"17\":1}}],[\"当\",{\"1\":{\"8\":2}}],[\"成功移动了一步\",{\"1\":{\"8\":1}}],[\"玩家输入\",{\"1\":{\"8\":1}}],[\"中传入\",{\"1\":{\"20\":1}}],[\"中存在的操作\",{\"1\":{\"18\":1}}],[\"中随机返回一个元素\",{\"1\":{\"12\":1}}],[\"中取一个随机数\",{\"1\":{\"12\":1}}],[\"中的其他行为时\",{\"1\":{\"8\":1}}],[\"中午吃什么\",{\"1\":{\"2\":1}}],[\"状态重置\",{\"1\":{\"52\":1}}],[\"状态\",{\"1\":{\"8\":1}}],[\"状态机开始循环\",{\"1\":{\"20\":1}}],[\"状态机会不断循环\",{\"1\":{\"8\":1}}],[\"状态机\",{\"0\":{\"8\":1},\"1\":{\"8\":1}}],[\"状态机的概念\",{\"1\":{\"4\":1}}],[\"为了保证平均时间复杂度\",{\"1\":{\"102\":1}}],[\"为元素的列表\",{\"1\":{\"12\":1}}],[\"为\",{\"1\":{\"8\":4,\"84\":1}}],[\"为什么呢\",{\"1\":{\"0\":1}}],[\"值为\",{\"1\":{\"17\":1}}],[\"值时\",{\"1\":{\"17\":1}}],[\"值\",{\"1\":{\"8\":1,\"17\":2}}],[\"值不存在时\",{\"1\":{\"5\":1}}],[\"程序不仅不会报错\",{\"1\":{\"8\":1}}],[\"程序就会报错\",{\"1\":{\"8\":1}}],[\"如果当前的数没放对\",{\"1\":{\"102\":1}}],[\"如果逆序就交换这两个元素\",{\"1\":{\"99\":1}}],[\"如果比5小就弹出\",{\"1\":{\"89\":1}}],[\"如果把3放进去\",{\"1\":{\"89\":1}}],[\"如果队列中存在两个元素\",{\"1\":{\"89\":1}}],[\"如果一个选手比你小还比你强\",{\"1\":{\"83\":1}}],[\"如果没见过使用栈来进行运算的题\",{\"1\":{\"77\":1}}],[\"如果没有可以移动的方向则游戏失败\",{\"1\":{\"50\":1}}],[\"如果没有\",{\"1\":{\"20\":1}}],[\"如果能就执行移动\",{\"1\":{\"48\":1}}],[\"如果能参加\",{\"1\":{\"2\":1}}],[\"如果\",{\"1\":{\"18\":1}}],[\"如果有任何一个\",{\"1\":{\"17\":1}}],[\"如果有任何一个元素大于\",{\"1\":{\"17\":1}}],[\"如果想不明白\",{\"1\":{\"16\":1}}],[\"如果存在的话\",{\"1\":{\"16\":1}}],[\"如果这个随机数大于\",{\"1\":{\"12\":1}}],[\"如果结束就返回相应的结束状态\",{\"1\":{\"8\":1}}],[\"如果要取的\",{\"1\":{\"8\":1}}],[\"读取用户输入得到\",{\"1\":{\"8\":2,\"20\":2}}],[\"展示游戏结束界面\",{\"1\":{\"8\":1}}],[\"功能\",{\"1\":{\"8\":2}}],[\"和归并排序不同\",{\"1\":{\"102\":1}}],[\"和k\",{\"1\":{\"85\":1}}],[\"和逆矩阵的概念无关\",{\"1\":{\"15\":1}}],[\"和\",{\"1\":{\"8\":3,\"12\":2,\"20\":2,\"89\":1,\"102\":2}}],[\"我没学过都是一个一个去网上搜😂\",{\"1\":{\"108\":1}}],[\"我也不会管它\",{\"1\":{\"108\":1}}],[\"我也知道\",{\"1\":{\"2\":1}}],[\"我每次看到这句话总会被莫名戳中笑点\",{\"1\":{\"91\":1}}],[\"我就高中的数学水平\",{\"1\":{\"70\":1}}],[\"我是一点都不会啊\",{\"1\":{\"70\":1}}],[\"我连题还没读明白他就给a了\",{\"1\":{\"60\":1}}],[\"我们还要关注一下序列长度的问题\",{\"1\":{\"89\":1}}],[\"我们还需要为玩家提供\",{\"1\":{\"8\":1}}],[\"我们要将队列中的元素从队尾挨个和5比较\",{\"1\":{\"89\":1}}],[\"我们需要思考\",{\"1\":{\"89\":1}}],[\"我们让1入队\",{\"1\":{\"89\":1}}],[\"我们发现一个性质\",{\"1\":{\"89\":1}}],[\"我们常人解决这个问题\",{\"1\":{\"88\":1}}],[\"我们因为这个wa了两发\",{\"1\":{\"60\":1}}],[\"我们就一起顺手把它a了\",{\"1\":{\"60\":1}}],[\"我们就可以补完主逻辑了\",{\"1\":{\"20\":1}}],[\"我们直接爆零\",{\"1\":{\"59\":1}}],[\"我们再结合两部分内容来理解\",{\"1\":{\"19\":1}}],[\"我们再用\",{\"1\":{\"16\":1}}],[\"我们只用实现判断能否向左移动的代码\",{\"1\":{\"18\":1}}],[\"我们使用了\",{\"1\":{\"17\":1}}],[\"我们先判断传进来作为\",{\"1\":{\"16\":1}}],[\"我们可以直接利用\",{\"1\":{\"15\":1}}],[\"我们往\",{\"1\":{\"12\":1}}],[\"我们用到了\",{\"1\":{\"12\":1}}],[\"我们都知道如果使用字典里不存在的\",{\"1\":{\"8\":1}}],[\"初始化函数\",{\"1\":{\"40\":1}}],[\"初始化游戏开始界面\",{\"1\":{\"13\":1}}],[\"初始化游戏棋盘\",{\"1\":{\"8\":1}}],[\"初始化棋盘的参数\",{\"1\":{\"10\":1}}],[\"初始化棋盘\",{\"1\":{\"8\":1}}],[\"终结状态结束程序\",{\"1\":{\"8\":1}}],[\"终端图形编程库\",{\"1\":{\"4\":1}}],[\"是c++中的一个关键字\",{\"1\":{\"112\":1}}],[\"是一个先进后出的数据结构\",{\"1\":{\"109\":1}}],[\"是一种被广泛运用的排序算法\",{\"1\":{\"102\":1}}],[\"是一种简单直观的排序算法\",{\"1\":{\"98\":1,\"99\":1,\"100\":1}}],[\"是\",{\"1\":{\"18\":1}}],[\"是返回下一个状态的函数\",{\"1\":{\"8\":1}}],[\"是状态\",{\"1\":{\"8\":1}}],[\"存储当前状态\",{\"1\":{\"8\":1}}],[\"游戏获胜条件\",{\"1\":{\"49\":1}}],[\"游戏结束\",{\"1\":{\"17\":1}}],[\"游戏结束时\",{\"1\":{\"8\":1}}],[\"游戏失败函数\",{\"1\":{\"50\":1}}],[\"游戏失败\",{\"1\":{\"17\":1}}],[\"游戏失败了\",{\"1\":{\"8\":1}}],[\"游戏胜利\",{\"1\":{\"17\":1}}],[\"游戏胜利了\",{\"1\":{\"8\":1}}],[\"游戏状态机\",{\"1\":{\"53\":1}}],[\"游戏状态\",{\"1\":{\"8\":1}}],[\"游戏很容易就能分解成几种状态的转换\",{\"1\":{\"8\":1}}],[\"游戏重置\",{\"1\":{\"7\":1}}],[\"处理游戏主逻辑的时候我们会用到一种十分常用的技术\",{\"1\":{\"8\":1}}],[\"6\",{\"1\":{\"84\":8,\"87\":1,\"88\":1}}],[\"68\",{\"1\":{\"7\":1}}],[\"65\",{\"1\":{\"7\":1}}],[\"的过程还是划分的过程\",{\"1\":{\"102\":1}}],[\"的滑动窗口\",{\"1\":{\"84\":1}}],[\"的数组\",{\"1\":{\"84\":1}}],[\"的作用是清空屏幕\",{\"1\":{\"19\":1}}],[\"的作用是绘制字符\",{\"1\":{\"19\":1}}],[\"的大小\",{\"1\":{\"17\":1}}],[\"的\",{\"1\":{\"16\":1,\"20\":2}}],[\"的二维矩阵\",{\"1\":{\"15\":1}}],[\"的输出结果为\",{\"1\":{\"7\":1}}],[\"的默认值\",{\"1\":{\"5\":1}}],[\"found\",{\"1\":{\"113\":1}}],[\"format\",{\"1\":{\"19\":1,\"43\":1,\"44\":1}}],[\"for\",{\"1\":{\"7\":1,\"12\":2,\"13\":2,\"14\":3,\"15\":2,\"16\":1,\"17\":3,\"18\":2,\"19\":2,\"23\":1,\"25\":2,\"26\":2,\"27\":1,\"28\":1,\"30\":2,\"31\":1,\"32\":1,\"36\":1,\"37\":1,\"40\":12,\"43\":1,\"44\":3,\"50\":1,\"89\":5,\"98\":2,\"99\":1,\"100\":1}}],[\"flag\",{\"1\":{\"99\":4}}],[\"flip\",{\"0\":{\"62\":1}}],[\"false\",{\"1\":{\"14\":2,\"16\":1,\"17\":1,\"18\":2,\"31\":2,\"36\":1,\"40\":3,\"46\":2,\"48\":1,\"99\":1,\"111\":1}}],[\"field\",{\"1\":{\"12\":2,\"13\":1,\"15\":4,\"16\":10,\"17\":1,\"18\":9,\"19\":1,\"20\":8}}],[\"fsm\",{\"1\":{\"8\":1}}],[\"from\",{\"1\":{\"5\":2}}],[\"便于和后面捕捉的键位关联\",{\"1\":{\"7\":1}}],[\"quicksort\",{\"1\":{\"102\":1}}],[\"q=\",{\"1\":{\"89\":6}}],[\"q是队列\",{\"1\":{\"89\":1}}],[\"q\",{\"1\":{\"7\":1,\"8\":1,\"19\":1,\"41\":1,\"44\":1,\"89\":12}}],[\"swap\",{\"1\":{\"98\":1,\"99\":1}}],[\"sort\",{\"1\":{\"98\":2,\"99\":2,\"100\":2,\"102\":1}}],[\"sorting\",{\"1\":{\"92\":1}}],[\"size++\",{\"1\":{\"111\":1}}],[\"size\",{\"1\":{\"25\":2,\"26\":2,\"40\":7,\"44\":4,\"46\":1,\"110\":3,\"111\":11}}],[\"successful\",{\"1\":{\"20\":1}}],[\"selection\",{\"1\":{\"98\":2}}],[\"self\",{\"1\":{\"10\":7,\"12\":5,\"13\":11,\"14\":1,\"16\":5,\"17\":7,\"18\":2,\"19\":8,\"23\":6,\"25\":6,\"26\":5,\"27\":3,\"28\":3,\"31\":1,\"32\":4,\"33\":4,\"34\":4,\"35\":4,\"37\":3,\"38\":4,\"39\":4,\"40\":57,\"42\":2,\"43\":2,\"44\":51,\"46\":8,\"47\":1,\"48\":4,\"49\":5,\"50\":5,\"51\":2,\"52\":2,\"53\":6,\"54\":3,\"55\":2,\"56\":2,\"57\":8}}],[\"separator\",{\"1\":{\"19\":3}}],[\"screen=self\",{\"1\":{\"47\":1}}],[\"screen=none\",{\"1\":{\"44\":1}}],[\"screen类用来绘制游戏界面\",{\"1\":{\"41\":1}}],[\"screen类\",{\"0\":{\"41\":1}}],[\"screen\",{\"0\":{\"47\":1},\"1\":{\"19\":6,\"20\":2,\"42\":1,\"44\":6,\"47\":2,\"53\":1,\"54\":1}}],[\"score=self\",{\"1\":{\"47\":1}}],[\"score=0\",{\"1\":{\"44\":2}}],[\"score\",{\"1\":{\"10\":1,\"13\":3,\"14\":1,\"19\":2,\"31\":1,\"40\":1,\"44\":6,\"46\":1,\"47\":1}}],[\"stack\",{\"1\":{\"109\":1}}],[\"staticmethod\",{\"1\":{\"36\":1,\"40\":2}}],[\"state\",{\"0\":{\"52\":1,\"53\":1,\"55\":1,\"56\":1},\"1\":{\"8\":4,\"20\":8,\"46\":1,\"52\":1,\"53\":1,\"55\":1,\"56\":1,\"57\":4}}],[\"stop\",{\"1\":{\"91\":1}}],[\"std\",{\"1\":{\"89\":1,\"98\":1,\"99\":1}}],[\"stdc++\",{\"1\":{\"89\":1}}],[\"stdscr\",{\"1\":{\"20\":9,\"23\":4,\"47\":1,\"57\":4}}],[\"st表算法\",{\"1\":{\"88\":1}}],[\"structure\",{\"0\":{\"121\":1}}],[\"string\",{\"1\":{\"19\":6,\"41\":2,\"42\":2,\"44\":8}}],[\"string2\",{\"1\":{\"19\":2,\"41\":1,\"44\":3}}],[\"string1\",{\"1\":{\"19\":2,\"41\":1,\"44\":3}}],[\"str\",{\"1\":{\"12\":1,\"19\":2,\"20\":1,\"44\":2}}],[\"spawn\",{\"1\":{\"12\":1,\"13\":2,\"16\":1}}],[\"s\",{\"1\":{\"7\":1,\"19\":1,\"41\":1,\"44\":1}}],[\"arraystack\",{\"1\":{\"111\":1}}],[\"arraystack<t>\",{\"1\":{\"110\":1,\"111\":1}}],[\"arraysize\",{\"1\":{\"110\":1,\"111\":5}}],[\"arrays\",{\"1\":{\"110\":1,\"111\":2}}],[\"algorithm\",{\"0\":{\"119\":1},\"1\":{\"92\":1}}],[\"alignment\",{\"0\":{\"69\":1}}],[\"a是原数组\",{\"1\":{\"89\":1}}],[\"acwing154\",{\"1\":{\"84\":1}}],[\"accounting\",{\"0\":{\"76\":1}}],[\"action类\",{\"0\":{\"23\":1}}],[\"action\",{\"1\":{\"8\":10,\"9\":1,\"20\":11,\"23\":1,\"50\":1,\"53\":7,\"54\":2,\"57\":2}}],[\"actions\",{\"1\":{\"7\":5,\"8\":2,\"9\":2,\"17\":1,\"20\":2,\"23\":5,\"50\":1}}],[\"a题严重低估难度了\",{\"1\":{\"60\":1}}],[\"add\",{\"0\":{\"26\":1},\"1\":{\"25\":2,\"26\":1,\"40\":3,\"48\":1}}],[\"addstr\",{\"1\":{\"19\":3,\"20\":2,\"42\":1,\"44\":1}}],[\"any\",{\"1\":{\"17\":11,\"18\":2,\"36\":1,\"37\":1,\"40\":2,\"50\":1}}],[\"and\",{\"1\":{\"14\":1,\"18\":2,\"31\":1,\"36\":2,\"40\":3}}],[\"assert\",{\"1\":{\"14\":1,\"31\":1,\"40\":1}}],[\"ascii\",{\"1\":{\"7\":1,\"9\":1}}],[\"append\",{\"1\":{\"14\":3,\"31\":3,\"40\":3}}],[\"a\",{\"1\":{\"7\":1,\"19\":1,\"41\":1,\"44\":1,\"89\":7,\"98\":5,\"99\":5,\"100\":9}}],[\"wheel\",{\"1\":{\"91\":1}}],[\"while\",{\"1\":{\"9\":1,\"20\":1,\"23\":1,\"57\":1,\"89\":6,\"99\":1,\"100\":1}}],[\"wormholes\",{\"0\":{\"65\":1}}],[\"wrapper\",{\"1\":{\"20\":4}}],[\"wiki\",{\"1\":{\"94\":1}}],[\"width\",{\"1\":{\"10\":2,\"12\":1,\"13\":1,\"19\":1}}],[\"width=4\",{\"1\":{\"10\":1}}],[\"win=self\",{\"1\":{\"47\":1}}],[\"win=false\",{\"1\":{\"44\":1}}],[\"win=2048\",{\"1\":{\"10\":1,\"20\":1}}],[\"window\",{\"1\":{\"20\":4}}],[\"win\",{\"0\":{\"49\":1,\"55\":1},\"1\":{\"8\":4,\"10\":1,\"17\":6,\"19\":4,\"20\":4,\"41\":2,\"44\":8,\"46\":1,\"47\":1,\"49\":4,\"53\":2,\"55\":1}}],[\"wasdrqwasdrq\",{\"1\":{\"7\":1,\"23\":1}}],[\"w\",{\"1\":{\"7\":1,\"19\":1,\"41\":1,\"44\":1}}],[\"wx\",{\"1\":{\"2\":3}}],[\"有一个大小为\",{\"1\":{\"84\":1}}],[\"有一个自己拥有绝对控制权的网站\",{\"1\":{\"0\":1}}],[\"有效输入键是最常见的\",{\"1\":{\"7\":1}}],[\"robot\",{\"0\":{\"80\":1}}],[\"robots\",{\"0\":{\"79\":1}}],[\"row\",{\"0\":{\"29\":1,\"36\":1,\"43\":1},\"1\":{\"14\":25,\"15\":4,\"16\":3,\"17\":2,\"18\":11,\"19\":6,\"27\":2,\"28\":2,\"30\":7,\"31\":16,\"32\":3,\"36\":8,\"37\":3,\"40\":43,\"43\":3,\"44\":9}}],[\"radar\",{\"0\":{\"73\":1}}],[\"range\",{\"1\":{\"12\":2,\"13\":2,\"14\":2,\"18\":1,\"25\":2,\"26\":2,\"30\":1,\"31\":1,\"36\":1,\"40\":7}}],[\"randrange\",{\"1\":{\"5\":1,\"12\":3,\"26\":1,\"40\":1}}],[\"random\",{\"0\":{\"26\":1},\"1\":{\"4\":1,\"5\":2,\"12\":1,\"25\":2,\"26\":3,\"40\":5,\"48\":1}}],[\"reinvent\",{\"1\":{\"91\":1}}],[\"refrigerator\",{\"0\":{\"71\":1}}],[\"reset\",{\"0\":{\"25\":1,\"46\":1},\"1\":{\"10\":1,\"13\":2,\"20\":1,\"25\":1,\"40\":2,\"46\":2,\"52\":1}}],[\"responses\",{\"1\":{\"8\":7,\"20\":4}}],[\"restart\",{\"0\":{\"54\":1},\"1\":{\"7\":3,\"8\":7,\"19\":1,\"20\":3,\"23\":3,\"41\":1,\"44\":1,\"53\":1,\"54\":2,\"55\":1,\"56\":1}}],[\"return\",{\"1\":{\"8\":7,\"9\":1,\"14\":3,\"15\":2,\"16\":2,\"17\":2,\"18\":6,\"20\":7,\"23\":1,\"30\":1,\"31\":2,\"36\":4,\"37\":1,\"38\":1,\"39\":1,\"40\":12,\"47\":1,\"48\":2,\"49\":1,\"50\":1,\"51\":1,\"52\":1,\"53\":5,\"54\":1,\"55\":1,\"56\":1,\"89\":1,\"111\":7}}],[\"r\",{\"1\":{\"7\":1,\"8\":1,\"19\":1,\"41\":1,\"44\":1}}],[\"right\",{\"0\":{\"33\":1,\"38\":1},\"1\":{\"7\":3,\"8\":2,\"16\":3,\"18\":2,\"19\":1,\"23\":3,\"33\":1,\"35\":1,\"38\":1,\"40\":5,\"41\":1,\"44\":1}}],[\"data\",{\"0\":{\"121\":1}}],[\"datas\",{\"1\":{\"110\":1,\"111\":7}}],[\"draw\",{\"0\":{\"43\":1,\"44\":1},\"1\":{\"19\":7,\"20\":4,\"43\":1,\"44\":5,\"53\":1,\"54\":1}}],[\"direction\",{\"1\":{\"16\":5,\"18\":4,\"48\":3,\"51\":2}}],[\"dict\",{\"1\":{\"7\":3,\"9\":2,\"23\":4}}],[\"default\",{\"1\":{\"20\":1,\"57\":1}}],[\"defaultdict\",{\"1\":{\"5\":2,\"8\":4,\"20\":1}}],[\"def\",{\"1\":{\"8\":3,\"9\":1,\"10\":1,\"12\":1,\"13\":1,\"14\":3,\"15\":2,\"16\":1,\"17\":2,\"18\":3,\"19\":4,\"20\":4,\"23\":2,\"25\":1,\"26\":1,\"27\":1,\"28\":1,\"30\":1,\"31\":1,\"32\":1,\"33\":1,\"34\":1,\"35\":1,\"36\":2,\"37\":1,\"38\":1,\"39\":1,\"40\":19,\"42\":1,\"43\":1,\"44\":5,\"46\":1,\"47\":1,\"48\":1,\"49\":1,\"50\":1,\"51\":1,\"52\":1,\"53\":1,\"54\":1,\"55\":1,\"56\":1,\"57\":1}}],[\"d\",{\"1\":{\"7\":1,\"19\":1,\"41\":1,\"44\":1,\"89\":1}}],[\"down\",{\"0\":{\"35\":1,\"40\":1},\"1\":{\"7\":3,\"8\":2,\"16\":2,\"18\":1,\"19\":1,\"23\":3,\"35\":1,\"40\":3,\"41\":1,\"44\":1}}],[\"life\",{\"0\":{\"114\":1}}],[\"line\",{\"1\":{\"19\":2,\"20\":1}}],[\"list\",{\"1\":{\"12\":1,\"15\":1,\"27\":1,\"40\":1}}],[\"live就好了\",{\"1\":{\"2\":1}}],[\"lambda\",{\"1\":{\"8\":3,\"16\":4,\"18\":4,\"20\":3}}],[\"lexicon\",{\"0\":{\"68\":1}}],[\"len\",{\"1\":{\"14\":6,\"18\":1,\"30\":2,\"31\":4,\"36\":1,\"40\":7}}],[\"letter\",{\"1\":{\"7\":2,\"23\":2}}],[\"left\",{\"0\":{\"29\":1,\"32\":1,\"36\":1,\"37\":1},\"1\":{\"7\":3,\"8\":2,\"14\":1,\"16\":5,\"18\":5,\"19\":1,\"23\":3,\"32\":2,\"33\":1,\"34\":1,\"36\":1,\"37\":2,\"38\":1,\"39\":1,\"40\":10,\"41\":1,\"44\":1}}],[\"=i\",{\"1\":{\"89\":3}}],[\"=a\",{\"1\":{\"89\":3}}],[\"==\",{\"1\":{\"8\":2,\"12\":1,\"14\":2,\"18\":2,\"20\":2,\"26\":1,\"31\":2,\"36\":2,\"40\":5,\"53\":2,\"54\":1,\"111\":4}}],[\"=\",{\"1\":{\"7\":3,\"8\":3,\"9\":2,\"10\":5,\"12\":3,\"13\":3,\"14\":6,\"16\":6,\"18\":7,\"19\":6,\"20\":9,\"23\":12,\"25\":1,\"26\":3,\"27\":1,\"28\":1,\"30\":2,\"31\":4,\"32\":1,\"36\":2,\"38\":1,\"39\":1,\"40\":21,\"41\":4,\"44\":10,\"46\":5,\"49\":1,\"50\":1,\"53\":1,\"57\":4,\"98\":4,\"99\":4,\"100\":5,\"111\":6}}],[\"表示还在游戏进行状态\",{\"1\":{\"8\":1}}],[\"表示\",{\"1\":{\"7\":1}}],[\"退出循环\",{\"1\":{\"8\":1}}],[\"退出\",{\"1\":{\"7\":2}}],[\"右边有数字时\",{\"1\":{\"18\":1}}],[\"右\",{\"1\":{\"7\":2}}],[\"左右上下\",{\"1\":{\"18\":1}}],[\"左\",{\"1\":{\"7\":2}}],[\"下面是完整代码\",{\"1\":{\"89\":1}}],[\"下面是一道标准的滑动窗口问题\",{\"1\":{\"83\":1}}],[\"下面对样例进行详细分析\",{\"1\":{\"89\":1}}],[\"下面我们来讲具体怎么使用单调队列\",{\"1\":{\"88\":1}}],[\"下面我们来理清主逻辑的代码\",{\"1\":{\"8\":1}}],[\"下面放一些比赛时的照骗\",{\"1\":{\"2\":1}}],[\"下\",{\"1\":{\"7\":2}}],[\"上次我因为无聊参加了它的那个python比赛\",{\"1\":{\"108\":1}}],[\"上述是求最大值大代码\",{\"1\":{\"89\":1}}],[\"上划返回桌面也不灵了\",{\"1\":{\"79\":1}}],[\"上\",{\"1\":{\"7\":2}}],[\"上面那个包菜还巨难吃\",{\"1\":{\"2\":1}}],[\"用来记录目前栈占用的大小\",{\"1\":{\"110\":1}}],[\"用来在终端上显示图形界面\",{\"1\":{\"5\":1}}],[\"用windows画图简单画的\",{\"1\":{\"83\":1}}],[\"用法参考上面代码块中的注释\",{\"1\":{\"12\":1}}],[\"用户输入处理\",{\"0\":{\"9\":1}}],[\"用户行为\",{\"0\":{\"7\":1}}],[\"用\",{\"1\":{\"7\":1}}],[\"可以见识一下这道题\",{\"1\":{\"77\":1}}],[\"可以看到我们给\",{\"1\":{\"20\":1}}],[\"可以向左合并\",{\"1\":{\"18\":1}}],[\"可以向左移动\",{\"1\":{\"18\":1}}],[\"可以在纸上画出变化前后的矩阵对比\",{\"1\":{\"16\":1}}],[\"可以直接从左移得到其余三个方向的移动操作\",{\"1\":{\"16\":1}}],[\"可以合并时\",{\"1\":{\"14\":1}}],[\"可以指定棋盘的高和宽以及游戏胜利条件\",{\"1\":{\"10\":1}}],[\"可以指定\",{\"1\":{\"5\":1}}],[\"可是我们需要知道象征着棋盘的这个二维数组的\",{\"1\":{\"12\":1}}],[\"可能自己的表达能力有限\",{\"1\":{\"81\":1}}],[\"可能是2\",{\"1\":{\"26\":1,\"40\":1}}],[\"可能是认为自己的学校的教育资源不如网上的吧\",{\"1\":{\"2\":1}}],[\"可能为2或4\",{\"1\":{\"26\":1}}],[\"可能以前真的很羡慕那些有自己博客的人\",{\"1\":{\"0\":1}}],[\"导入需要的包\",{\"1\":{\"5\":1}}],[\"容器数据类型库\",{\"1\":{\"4\":1}}],[\"技术栈\",{\"0\":{\"4\":1}}],[\"哈哈哈\",{\"1\":{\"3\":1}}],[\"应该不难吧\",{\"1\":{\"3\":1}}],[\"应该是第一场icpc网络预选赛\",{\"1\":{\"2\":1}}],[\"目前拿过的最高荣誉\",{\"1\":{\"2\":1}}],[\"目前维持自己的精神状态正常才最重要hhh\",{\"1\":{\"2\":1}}],[\"大的数冒到最后面\",{\"1\":{\"99\":1}}],[\"大概分为三类\",{\"1\":{\"92\":1}}],[\"大概是纯模拟\",{\"1\":{\"80\":1}}],[\"大概是第二场吧\",{\"1\":{\"2\":1}}],[\"大家都挺不容易的\",{\"1\":{\"59\":1}}],[\"大学四年浪费八分之五\",{\"1\":{\"2\":1}}],[\"c++中的this\",{\"0\":{\"112\":1}}],[\"c++\",{\"1\":{\"98\":1,\"99\":1,\"100\":1}}],[\"cin\",{\"1\":{\"89\":2}}],[\"crashing\",{\"0\":{\"79\":1}}],[\"cryptography\",{\"0\":{\"75\":1}}],[\"cr11u\",{\"1\":{\"2\":1}}],[\"currency\",{\"0\":{\"64\":1}}],[\"curses\",{\"1\":{\"4\":1,\"5\":2,\"19\":1,\"20\":7,\"57\":1}}],[\"cells\",{\"1\":{\"25\":1,\"26\":4,\"27\":2,\"28\":2,\"32\":2,\"37\":1,\"40\":13,\"44\":2,\"49\":1}}],[\"clear\",{\"1\":{\"19\":2,\"20\":2,\"44\":2}}],[\"class\",{\"1\":{\"10\":1,\"23\":1,\"40\":1,\"44\":1,\"110\":1,\"111\":1}}],[\"cash\",{\"0\":{\"67\":1}}],[\"cast\",{\"0\":{\"42\":1},\"1\":{\"19\":10,\"42\":1,\"43\":1,\"44\":16}}],[\"call\",{\"0\":{\"57\":1},\"1\":{\"57\":1}}],[\"callable\",{\"1\":{\"8\":1}}],[\"can\",{\"0\":{\"36\":1,\"37\":1,\"38\":1,\"39\":1,\"40\":1,\"51\":1},\"1\":{\"36\":1,\"37\":2,\"38\":4,\"39\":4,\"40\":19,\"48\":1,\"50\":1,\"51\":2}}],[\"camera\",{\"1\":{\"2\":3}}],[\"check\",{\"1\":{\"18\":11}}],[\"chain\",{\"1\":{\"49\":1}}],[\"change\",{\"1\":{\"18\":2,\"36\":2,\"40\":2}}],[\"char\",{\"1\":{\"9\":4,\"23\":4}}],[\"ch\",{\"1\":{\"7\":2,\"23\":2}}],[\"choice\",{\"1\":{\"5\":1,\"12\":4,\"26\":1,\"40\":1}}],[\"coding\",{\"0\":{\"117\":1}}],[\"code\",{\"0\":{\"70\":1},\"1\":{\"89\":1}}],[\"codes\",{\"1\":{\"7\":2,\"23\":2}}],[\"contest\",{\"0\":{\"116\":1}}],[\"copyof\",{\"1\":{\"111\":1}}],[\"com\",{\"1\":{\"89\":1}}],[\"cout\",{\"1\":{\"89\":4}}],[\"counter\",{\"1\":{\"44\":1}}],[\"cow\",{\"0\":{\"68\":1}}],[\"colors\",{\"1\":{\"20\":1,\"57\":1}}],[\"collections\",{\"1\":{\"4\":1,\"5\":2}}],[\"ccpc和icpc的网络选拔赛\",{\"1\":{\"2\":1}}],[\"ccpc网络赛结束\",{\"1\":{\"0\":1}}],[\"ccpc河南省赛结束\",{\"1\":{\"0\":1}}],[\"算法性质\",{\"0\":{\"93\":1}}],[\"算法笔记\",{\"0\":{\"81\":1,\"90\":1}}],[\"算法呀\",{\"1\":{\"60\":1}}],[\"算法固然算是一个梦想\",{\"1\":{\"2\":1}}],[\"算起来都太亏了\",{\"1\":{\"2\":1}}],[\"现在腰还是痛的\",{\"1\":{\"73\":1}}],[\"现在或许我应该把重心放到更加稳妥的方向了吧\",{\"1\":{\"2\":1}}],[\"现在在寝室里面最大的事情也不过是早上吃什么\",{\"1\":{\"2\":1}}],[\"世界上总是有一些事与愿违的事情\",{\"1\":{\"2\":1}}],[\"写之前千万别看评论区\",{\"1\":{\"75\":1}}],[\"写出来并不能改变什么\",{\"1\":{\"2\":1}}],[\"写写文章\",{\"1\":{\"2\":1}}],[\"所有代码\",{\"1\":{\"40\":1,\"44\":1}}],[\"所有的有效输入都可以转换为\",{\"1\":{\"7\":1}}],[\"所以直接拼接起来就好了\",{\"1\":{\"102\":1}}],[\"所以处理后3\",{\"1\":{\"89\":1}}],[\"所以入队\",{\"1\":{\"89\":1}}],[\"所以这次不弹出元素\",{\"1\":{\"89\":1}}],[\"所以把1弹出3入队\",{\"1\":{\"89\":1}}],[\"所以可以直接将\",{\"1\":{\"89\":1}}],[\"所以由此得知我们只能选用时间复杂度在\",{\"1\":{\"88\":1}}],[\"所以标准就降低一些\",{\"1\":{\"81\":1}}],[\"所以加紧复习一下dp\",{\"1\":{\"66\":1}}],[\"所以我们来结合上一部分出现的\",{\"1\":{\"20\":1}}],[\"所以矩阵变换之后\",{\"1\":{\"18\":1}}],[\"所以需要传一个函数\",{\"1\":{\"8\":1}}],[\"所以就跑过来跟着实现一下这个\",{\"1\":{\"3\":1}}],[\"所以在这里写出来发泄一下\",{\"1\":{\"2\":1}}],[\"所谓的新冠疫情已经耽误了太多太多的事情了\",{\"1\":{\"2\":1}}],[\"越想越难受\",{\"1\":{\"2\":1}}],[\"确实是心里有点难受\",{\"1\":{\"2\":1}}],[\"确实是一个错误的观点\",{\"1\":{\"2\":1}}],[\"没有想象中的翘边\",{\"1\":{\"79\":1}}],[\"没有结束就返回状态\",{\"1\":{\"8\":1}}],[\"没有结果\",{\"1\":{\"2\":1}}],[\"没有那个运气和实力\",{\"1\":{\"2\":1}}],[\"没有什么逻辑\",{\"1\":{\"2\":1}}],[\"没有什么条理\",{\"1\":{\"2\":1}}],[\"没有任何别的意思\",{\"1\":{\"2\":1}}],[\"那一场打的真的难\",{\"1\":{\"108\":1}}],[\"那队列就会变成\",{\"1\":{\"89\":1}}],[\"那么可以交换\",{\"1\":{\"102\":1}}],[\"那么无论在什么时候我们都不会取\",{\"1\":{\"89\":1}}],[\"那么在这里是必然会超时的\",{\"1\":{\"88\":1}}],[\"那就执行它对应的函数\",{\"1\":{\"18\":1}}],[\"那这两年半的训练算是打水漂了\",{\"1\":{\"2\":1}}],[\"那个菜还十分难吃\",{\"1\":{\"2\":1}}],[\"只需检查一遍数组\",{\"1\":{\"99\":1,\"100\":1}}],[\"只是留给以后的自己看\",{\"1\":{\"81\":1}}],[\"只觉得很瞌睡😪\",{\"1\":{\"78\":1}}],[\"只能说疫情当下\",{\"1\":{\"59\":1}}],[\"只能说是拼死拼活\",{\"1\":{\"2\":1}}],[\"只要游戏没有胜利或失败\",{\"1\":{\"8\":1}}],[\"只有胜利和失败两种结果\",{\"1\":{\"8\":1}}],[\"只为了打明年的比赛\",{\"1\":{\"2\":1}}],[\"训练了一年半了\",{\"1\":{\"2\":1}}],[\"不论是选择\",{\"1\":{\"102\":1}}],[\"不论是时间成本还是精力\",{\"1\":{\"2\":1}}],[\"不用合并\",{\"1\":{\"102\":1}}],[\"不用再变换复原\",{\"1\":{\"18\":1}}],[\"不包括这个函数的低阶项和首项系数\",{\"1\":{\"95\":1}}],[\"不仅效率高\",{\"1\":{\"91\":1}}],[\"不可能要求一个程序员就把它完整的编写出来\",{\"1\":{\"91\":1}}],[\"不要重复造轮子\",{\"1\":{\"91\":1}}],[\"不知道为啥\",{\"1\":{\"80\":1}}],[\"不知不觉在寝室已经封了十天了\",{\"1\":{\"2\":1}}],[\"不然评论区有答案就没意思了\",{\"1\":{\"75\":1}}],[\"不需要遇到换行符或回车\",{\"1\":{\"20\":1}}],[\"不是逆矩阵\",{\"1\":{\"15\":1}}],[\"不能合并\",{\"1\":{\"14\":1}}],[\"不同的是\",{\"1\":{\"8\":1}}],[\"不存在\",{\"1\":{\"8\":1}}],[\"不过总的来说这句话对于大部分程序员是对的\",{\"1\":{\"91\":1}}],[\"不过在这里有点大材小用了\",{\"1\":{\"88\":1}}],[\"不过是看一眼找到方框里哪个最大哪个最小就行了\",{\"1\":{\"88\":1}}],[\"不过这个膜才9块9\",{\"1\":{\"79\":1}}],[\"不过今天新生来了还挺热闹的\",{\"1\":{\"77\":1}}],[\"不过还好手速快\",{\"1\":{\"65\":1}}],[\"不过还好\",{\"1\":{\"62\":1}}],[\"不过\",{\"1\":{\"2\":1}}],[\"估计只能等到明年再打了\",{\"1\":{\"2\":1}}],[\"报名过的比赛被迫退赛\",{\"1\":{\"2\":1}}],[\"拿个铜牌也是足够拿到简历上加很多分的\",{\"1\":{\"2\":1}}],[\"打下来了几个名额\",{\"1\":{\"2\":1}}],[\"虽然难\",{\"1\":{\"108\":1}}],[\"虽然题目和故事一点关系都没有😂\",{\"1\":{\"76\":1}}],[\"虽然dp真的好难😂\",{\"1\":{\"66\":1}}],[\"虽然没什么难度\",{\"1\":{\"62\":1}}],[\"虽然我们队伍不是最强的\",{\"1\":{\"2\":1}}],[\"虽然很喜欢扩展一些编程知识\",{\"1\":{\"2\":1}}],[\"甚至封寝前几天还打了一场河北省赛\",{\"1\":{\"2\":1}}],[\"疫情之前连着打了一个月的比赛\",{\"1\":{\"2\":1}}],[\"米还有点生\",{\"1\":{\"2\":1}}],[\"这几天除了要准备ccpc\",{\"1\":{\"108\":1}}],[\"这就不一样了\",{\"1\":{\"89\":1}}],[\"这就很亏了\",{\"1\":{\"60\":1}}],[\"这样没人负责一个模块\",{\"1\":{\"91\":1}}],[\"这样的算法时间复杂度大概是\",{\"1\":{\"88\":1}}],[\"这样一来\",{\"1\":{\"8\":1}}],[\"这是队列的特性\",{\"1\":{\"83\":1}}],[\"这是第一次写算法笔记\",{\"1\":{\"81\":1}}],[\"这道题也很简单\",{\"1\":{\"80\":1}}],[\"这道题很简单\",{\"1\":{\"79\":1}}],[\"这道题挺简单的\",{\"1\":{\"77\":1}}],[\"这道题真的严重浪费了很多很多的时间\",{\"1\":{\"60\":1}}],[\"这题有亿点简单\",{\"1\":{\"75\":1}}],[\"这题tm卡cin\",{\"1\":{\"60\":1}}],[\"这次写的还是很顺利的\",{\"1\":{\"62\":1}}],[\"这次比赛打的真是艰难\",{\"1\":{\"59\":1}}],[\"这部分代码的关键在于\",{\"1\":{\"19\":1}}],[\"这两个判断都通过后\",{\"1\":{\"16\":1}}],[\"这两种行为时分别对应\",{\"1\":{\"8\":1}}],[\"这一端被称为栈顶\",{\"1\":{\"109\":1}}],[\"这一题好像是关于千年虫病毒的吧\",{\"1\":{\"76\":1}}],[\"这一步是在棋盘类内定义的\",{\"1\":{\"19\":1}}],[\"这一操作是在\",{\"1\":{\"14\":1}}],[\"这一来疫情耽误了\",{\"1\":{\"2\":1}}],[\"这里使用数组实现模拟栈\",{\"1\":{\"110\":1}}],[\"这里推荐一下我在别人博客见到的一句话\",{\"1\":{\"83\":1}}],[\"这里是有一个格子达到2048就算获胜\",{\"1\":{\"49\":1}}],[\"这里我们先记住\",{\"1\":{\"19\":1}}],[\"这里只用进行判断\",{\"1\":{\"18\":1}}],[\"这里只是将矩阵的每一行倒序\",{\"1\":{\"15\":1}}],[\"这里的主要内容在实验的开始就分析过了\",{\"1\":{\"20\":1}}],[\"这里的\",{\"1\":{\"17\":1}}],[\"这里的难点在于理解矩阵转置和逆转后和原矩阵的关系\",{\"1\":{\"16\":1}}],[\"这里省略\",{\"1\":{\"16\":1}}],[\"这里需要在棋盘中随机找到一个空白的位置\",{\"1\":{\"12\":1}}],[\"这里同样会获取用户输入得到\",{\"1\":{\"8\":1}}],[\"这里\",{\"1\":{\"8\":1}}],[\"这里要考虑到大写键开启的情况\",{\"1\":{\"7\":1}}],[\"这六种行为\",{\"1\":{\"7\":1}}],[\"这个题数据量很小\",{\"1\":{\"78\":1}}],[\"这个传进去的函数必须满足第一个参数为主窗体\",{\"1\":{\"20\":1}}],[\"这个特殊字典里\",{\"1\":{\"8\":1}}],[\"这个词典变量作为状态转换的规则\",{\"1\":{\"8\":1}}],[\"这个curses后面真的折磨了我好久\",{\"1\":{\"5\":1}}],[\"这个图里能看到的肉几乎就是全部了\",{\"1\":{\"2\":1}}],[\"这也是我这几天这几十天咕咕咕连个破文章都没更新的原因\",{\"1\":{\"2\":1}}],[\"一般这种小比赛都是没人参加的\",{\"1\":{\"108\":1}}],[\"一般是随机选择一个数\",{\"1\":{\"102\":1}}],[\"一般来说这样会效率低下\",{\"1\":{\"91\":1}}],[\"一直循环\",{\"1\":{\"89\":1}}],[\"一直没debug出来\",{\"1\":{\"68\":1}}],[\"一下的算法\",{\"1\":{\"88\":1}}],[\"一下午罚坐了5个小时\",{\"1\":{\"73\":1}}],[\"一\",{\"0\":{\"81\":1}}],[\"一开始队中没有一个元素\",{\"1\":{\"89\":1}}],[\"一开始是感觉这个题巨难\",{\"1\":{\"60\":1}}],[\"一开始想复杂了\",{\"1\":{\"60\":1}}],[\"一开始定了一个目标\",{\"1\":{\"2\":1}}],[\"一行向左合并\",{\"0\":{\"14\":1}}],[\"一盆菜里面面就几个肉丝\",{\"1\":{\"2\":1}}],[\"以此类推\",{\"1\":{\"89\":1}}],[\"以下是一个例子\",{\"1\":{\"84\":1}}],[\"以及分数\",{\"1\":{\"41\":1}}],[\"以外的键位都不能对游戏界面造成影响\",{\"1\":{\"8\":1}}],[\"以至于是几乎不能吃的感觉\",{\"1\":{\"2\":1}}],[\"以后坚持每周模拟战吧\",{\"1\":{\"0\":1}}],[\"饭菜虽然免费\",{\"1\":{\"2\":1}}],[\"还参加了一个蓝桥云课的小比赛\",{\"1\":{\"108\":1}}],[\"还想买把椅子\",{\"1\":{\"78\":1}}],[\"还真看不出来这是组合数\",{\"1\":{\"70\":1}}],[\"还加了dp的buff\",{\"1\":{\"60\":1}}],[\"还能取到一个我们设定的默认\",{\"1\":{\"8\":1}}],[\"还有大模拟\",{\"1\":{\"66\":1}}],[\"还有河南省赛\",{\"1\":{\"2\":1}}],[\"还有给新生出的题现在还有几道没出\",{\"1\":{\"2\":1}}],[\"还可以偶尔看看书\",{\"1\":{\"2\":1}}],[\"基数排序\",{\"0\":{\"105\":1},\"1\":{\"92\":1}}],[\"基本知识\",{\"1\":{\"4\":1}}],[\"基本上只完成了老师布置的作业\",{\"1\":{\"2\":1}}],[\"基于wordpress的博客上线\",{\"1\":{\"0\":1}}],[\"对\",{\"1\":{\"100\":1}}],[\"对程序进行封装和打包\",{\"1\":{\"91\":1}}],[\"对数组中每个元素进行处理\",{\"1\":{\"89\":1}}],[\"对应四种棋盘操作\",{\"1\":{\"16\":1}}],[\"对应不同的方法函数\",{\"1\":{\"16\":1}}],[\"对应的都是默认的\",{\"1\":{\"8\":1}}],[\"对于像我们棋盘一样\",{\"1\":{\"15\":1}}],[\"对于算法的学习也搁置了\",{\"1\":{\"2\":1}}],[\"对邻近元素进行合并\",{\"1\":{\"14\":1}}],[\"对学习根本打不起兴趣\",{\"1\":{\"2\":1}}],[\"碰到难以解决的问题就搁置了\",{\"1\":{\"2\":1}}],[\"但也是o\",{\"1\":{\"60\":1}}],[\"但b题签到最后没有写出来\",{\"1\":{\"60\":1}}],[\"但在\",{\"1\":{\"8\":1}}],[\"但其质量很堪忧\",{\"1\":{\"2\":1}}],[\"但没什么斗志\",{\"1\":{\"2\":1}}],[\"但是为了规范和安全还是建议在访问对象成员变量时加上this\",{\"1\":{\"112\":1}}],[\"但是那一场比赛我真的学到了很多实用的东西\",{\"1\":{\"108\":1}}],[\"但是它很靠前\",{\"1\":{\"89\":1}}],[\"但是也不能排除以后的元素都比它还要小\",{\"1\":{\"89\":1}}],[\"但是如果想要加入这个队列就只能从队头或者队尾进入\",{\"1\":{\"83\":1}}],[\"但是容易想歪\",{\"1\":{\"75\":1}}],[\"但是我觉得对于新入行的程序员\",{\"1\":{\"91\":1}}],[\"但是我们看一下数据范围\",{\"1\":{\"88\":1}}],[\"但是我叕写了很长时间\",{\"1\":{\"68\":1}}],[\"但是我忘了怎么做了\",{\"1\":{\"67\":1}}],[\"但是队伍排名还在800名左右\",{\"1\":{\"65\":1}}],[\"但是还是十分考验码代码的能力的\",{\"1\":{\"62\":1}}],[\"但是还是要脚踏实地学点什么养活自己再说\",{\"1\":{\"2\":1}}],[\"但是时间不太够了\",{\"1\":{\"60\":1}}],[\"但是意见不是很统一\",{\"1\":{\"60\":1}}],[\"但是感觉这场打的很难受\",{\"1\":{\"59\":1}}],[\"但是\",{\"1\":{\"2\":1,\"108\":1}}],[\"但是都是php真的看不懂啊\",{\"1\":{\"0\":1}}],[\"但是没有什么特别开心的\",{\"1\":{\"0\":1}}],[\"但是可能自己真的有赛博仓鼠的囤积癖\",{\"1\":{\"0\":1}}],[\"被封寝之后的物资短缺几乎让我退化到了只要keep\",{\"1\":{\"2\":1}}],[\"封寝几天之后逐渐就开始崩坏了\",{\"1\":{\"2\":1}}],[\"封寝十天小记\",{\"0\":{\"2\":1}}],[\"i>=k\",{\"1\":{\"89\":3}}],[\"i++\",{\"1\":{\"89\":5,\"98\":1,\"99\":1}}],[\"i<=n\",{\"1\":{\"89\":5}}],[\"i=1\",{\"1\":{\"89\":5}}],[\"item\",{\"0\":{\"26\":1},\"1\":{\"25\":2,\"26\":1,\"40\":3,\"48\":1}}],[\"iterable\",{\"1\":{\"17\":1}}],[\"isempty\",{\"1\":{\"110\":1,\"111\":1}}],[\"is\",{\"0\":{\"49\":1,\"50\":1},\"1\":{\"16\":2,\"17\":5,\"18\":4,\"19\":2,\"20\":2,\"49\":1,\"50\":1,\"53\":2}}],[\"i\",{\"1\":{\"12\":7,\"13\":1,\"14\":11,\"17\":2,\"18\":8,\"25\":1,\"26\":5,\"30\":4,\"31\":7,\"36\":8,\"40\":25,\"89\":11,\"98\":5,\"99\":6,\"100\":4}}],[\"if\",{\"1\":{\"8\":5,\"12\":2,\"13\":1,\"14\":3,\"16\":2,\"18\":3,\"19\":4,\"20\":5,\"26\":2,\"30\":1,\"31\":2,\"36\":2,\"40\":7,\"43\":1,\"44\":5,\"48\":1,\"53\":5,\"54\":1,\"89\":3,\"98\":1,\"99\":1,\"111\":4}}],[\"insertion\",{\"1\":{\"100\":2}}],[\"installation\",{\"0\":{\"73\":1}}],[\"inline\",{\"1\":{\"89\":2}}],[\"include<bits\",{\"1\":{\"89\":1}}],[\"int\",{\"1\":{\"89\":11,\"98\":5,\"99\":3,\"100\":5,\"110\":1,\"111\":2}}],[\"invert\",{\"0\":{\"28\":1},\"1\":{\"15\":1,\"16\":2,\"18\":1,\"28\":1,\"33\":2,\"38\":2,\"40\":5}}],[\"init函数用来初始化我们的游戏棋盘\",{\"1\":{\"8\":1}}],[\"init\",{\"0\":{\"52\":1},\"1\":{\"8\":8,\"10\":1,\"20\":6,\"23\":1,\"40\":1,\"44\":1,\"46\":1,\"52\":1,\"53\":1,\"54\":1}}],[\"in\",{\"1\":{\"7\":1,\"9\":1,\"12\":2,\"13\":2,\"14\":3,\"15\":2,\"16\":2,\"17\":3,\"18\":3,\"19\":2,\"23\":2,\"25\":2,\"26\":2,\"27\":1,\"28\":1,\"30\":2,\"31\":1,\"32\":1,\"36\":1,\"37\":1,\"40\":12,\"43\":1,\"44\":3,\"50\":1}}],[\"import\",{\"1\":{\"5\":3,\"110\":1,\"111\":1}}],[\"img\",{\"1\":{\"2\":2,\"83\":1}}],[\"icpc亚洲区域赛的名额真的是太宝贵了\",{\"1\":{\"2\":1}}],[\"icpc网络赛content1结束了\",{\"1\":{\"0\":1}}],[\"icpc网络赛content2结束了\",{\"1\":{\"0\":1}}],[\"就像大多数面向对象的编程语言一样\",{\"1\":{\"112\":1}}],[\"就像打poker整理手牌一样\",{\"1\":{\"100\":1}}],[\"就像排队一样从高到低排\",{\"1\":{\"83\":1}}],[\"就扫描一遍方框\",{\"1\":{\"88\":1}}],[\"就返回\",{\"1\":{\"17\":2}}],[\"就会对棋盘进行相应移动操作\",{\"1\":{\"16\":1}}],[\"就会一直处于游戏状态\",{\"1\":{\"8\":1}}],[\"就是类似下面这样一个队列\",{\"1\":{\"83\":1}}],[\"就是构建一个队列\",{\"1\":{\"83\":1}}],[\"就是指纹解锁变慢了\",{\"1\":{\"79\":1}}],[\"就是很不爽\",{\"1\":{\"2\":1}}],[\"就是在保证正常学习的进度下再把java的springboot框架给学了\",{\"1\":{\"2\":1}}],[\"就该抛弃所有杂念\",{\"1\":{\"0\":1}}],[\"窝在寝室里默默的学习和努力还是挺好的\",{\"1\":{\"2\":1}}],[\"在大多数情况下\",{\"1\":{\"112\":1}}],[\"在排序过的列表中r也将会是在s之前\",{\"1\":{\"94\":1}}],[\"在网上经常见到一句程序员对新入行的新人说的话\",{\"1\":{\"91\":1}}],[\"在这里也即\",{\"1\":{\"88\":1}}],[\"在这个模式下会禁止输入的字符显示在终端上\",{\"1\":{\"20\":1}}],[\"在前面的代码里\",{\"1\":{\"20\":1}}],[\"在下一部分主逻辑后面\",{\"1\":{\"19\":1}}],[\"在上面的代码中\",{\"1\":{\"12\":1}}],[\"在上面记录自己的点滴成长\",{\"1\":{\"0\":1}}],[\"在不重新开始或退出的情况下\",{\"1\":{\"8\":1}}],[\"在游戏结束界面\",{\"1\":{\"8\":1}}],[\"在\",{\"1\":{\"8\":3,\"16\":1,\"17\":1,\"18\":1,\"19\":1,\"20\":1}}],[\"在普通的字典里\",{\"1\":{\"8\":1}}],[\"在字典中新建两个键值对\",{\"1\":{\"8\":1}}],[\"在展示这两种结果的同时\",{\"1\":{\"8\":1}}],[\"在根目录下创建游戏文件\",{\"1\":{\"5\":1}}],[\"在刚封寝的那几天我其实内心还是有点欣喜的\",{\"1\":{\"2\":1}}],[\"看漏了是真的害人\",{\"1\":{\"60\":1}}],[\"看到某网站上有一门实战课\",{\"1\":{\"3\":1}}],[\"看着平常里熙熙攘攘的校园还有宿舍的走廊里变得如此宁静\",{\"1\":{\"2\":1}}],[\"看起来也没什么了不起嘛\",{\"1\":{\"0\":1}}],[\"走廊\",{\"1\":{\"2\":1}}],[\"能进脑子的知识估计能有十分之一都不错了\",{\"1\":{\"2\":1}}],[\"晚上吃什么\",{\"1\":{\"2\":1}}],[\"push\",{\"1\":{\"110\":1,\"111\":1}}],[\"public\",{\"1\":{\"110\":1,\"111\":7}}],[\"putchar\",{\"1\":{\"89\":1}}],[\"p=\",{\"1\":{\"89\":4}}],[\"private\",{\"1\":{\"110\":2,\"111\":2}}],[\"printf\",{\"1\":{\"89\":1}}],[\"property\",{\"1\":{\"47\":1,\"49\":1,\"50\":1}}],[\"projects\",{\"0\":{\"1\":1,\"115\":1}}],[\"p用来存储队列中元素在原数组中的序号\",{\"1\":{\"89\":1}}],[\"p\",{\"1\":{\"89\":9}}],[\"pdd有的时候真的挺便宜的\",{\"1\":{\"80\":1}}],[\"partition\",{\"1\":{\"102\":1}}],[\"parencodings\",{\"0\":{\"78\":1}}],[\"pair\",{\"1\":{\"14\":4,\"31\":4,\"40\":4}}],[\"pop\",{\"1\":{\"110\":1,\"111\":1}}],[\"power\",{\"0\":{\"75\":1}}],[\"possible\",{\"1\":{\"16\":2,\"17\":1,\"18\":2}}],[\"pilots\",{\"0\":{\"71\":1}}],[\"ps\",{\"1\":{\"5\":1}}],[\"py\",{\"1\":{\"5\":1}}],[\"python\",{\"1\":{\"4\":1,\"15\":1,\"17\":1}}],[\"python实现2048\",{\"0\":{\"3\":1}}],[\"png\",{\"1\":{\"2\":1}}],[\"既然选择在xcpc这条路上走\",{\"1\":{\"0\":1}}],[\"5\",{\"1\":{\"0\":1,\"84\":9,\"87\":1,\"88\":2,\"89\":3}}],[\"呜呜呜~~~\",{\"1\":{\"70\":1}}],[\"呜呜呜~\",{\"1\":{\"0\":1}}],[\"89\",{\"1\":{\"12\":2}}],[\"81\",{\"1\":{\"7\":1}}],[\"82\",{\"1\":{\"7\":1}}],[\"83\",{\"1\":{\"7\":1}}],[\"87\",{\"1\":{\"7\":1}}],[\"8\",{\"1\":{\"0\":1,\"21\":1,\"87\":1}}],[\"🥳\",{\"1\":{\"0\":1}}],[\"1和\",{\"1\":{\"89\":1}}],[\"1同理\",{\"1\":{\"89\":1}}],[\"1入队\",{\"1\":{\"89\":1}}],[\"1\",{\"1\":{\"8\":2,\"14\":2,\"15\":1,\"18\":3,\"19\":1,\"21\":1,\"28\":1,\"31\":2,\"36\":3,\"40\":6,\"84\":15,\"87\":2,\"88\":1,\"89\":9,\"98\":2,\"99\":3,\"100\":4,\"111\":1}}],[\"1664527222954\",{\"1\":{\"2\":1}}],[\"1664680508938\",{\"1\":{\"2\":1}}],[\"1663385267713\",{\"1\":{\"2\":1}}],[\"162248\",{\"1\":{\"2\":1}}],[\"113\",{\"1\":{\"7\":1}}],[\"114\",{\"1\":{\"7\":1}}],[\"115\",{\"1\":{\"7\":1}}],[\"119\",{\"1\":{\"7\":1}}],[\"11\",{\"1\":{\"0\":1}}],[\"12\",{\"1\":{\"0\":2}}],[\"181748\",{\"1\":{\"2\":1}}],[\"18\",{\"1\":{\"0\":1}}],[\"1000001\",{\"1\":{\"89\":7}}],[\"100\",{\"1\":{\"7\":1,\"12\":2,\"26\":1,\"40\":1}}],[\"101842854\",{\"1\":{\"2\":1}}],[\"10\",{\"1\":{\"0\":1}}],[\"两场比赛依旧是一个名额都没抢到\",{\"1\":{\"0\":1}}],[\"90\",{\"1\":{\"26\":1,\"40\":1}}],[\"97\",{\"1\":{\"7\":1}}],[\"9\",{\"1\":{\"0\":4}}],[\"咱也拿了个第一个金牌\",{\"1\":{\"0\":1}}],[\"整个学校打的也争气的\",{\"1\":{\"0\":1}}],[\"2048\",{\"1\":{\"5\":1,\"8\":1,\"10\":2,\"20\":1}}],[\"20221023\",{\"1\":{\"2\":1}}],[\"20221028\",{\"1\":{\"2\":1}}],[\"20221106\",{\"1\":{\"2\":1}}],[\"2022\",{\"1\":{\"0\":7}}],[\"22\",{\"1\":{\"0\":1}}],[\"25\",{\"1\":{\"0\":1}}],[\"2\",{\"0\":{\"12\":1},\"1\":{\"0\":1,\"7\":1,\"8\":1,\"12\":3,\"14\":3,\"21\":1,\"26\":1,\"31\":2,\"40\":3,\"89\":4,\"100\":2,\"111\":4}}],[\"想想也是一件很幸福的事情\",{\"1\":{\"0\":1}}],[\"呵\",{\"1\":{\"0\":1}}],[\"关于\",{\"0\":{\"0\":1}}]],\"version\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n,id:o}})=>{const u=bt[s];e==="suggest"?self.postMessage([e,o,tt(t,u,n)]):e==="search"?self.postMessage([e,o,Z(t,u,n)]):self.postMessage({suggestions:[e,o,tt(t,u,n)],results:[e,o,Z(t,u,n)]})};
//# sourceMappingURL=index.js.map
